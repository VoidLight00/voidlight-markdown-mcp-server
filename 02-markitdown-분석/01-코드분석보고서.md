# MarkItDown 코드 분석 보고서

## 1. 전체 아키텍처 분석

### 1.1 모노레포 구조
```
markitdown/
├── packages/
│   ├── markitdown/                   # 핵심 라이브러리
│   ├── markitdown-mcp/              # MCP 서버 구현
│   └── markitdown-sample-plugin/    # 샘플 플러그인
├── Dockerfile                       # CLI 컨테이너 이미지
└── README.md                        # 메인 문서
```

### 1.2 핵심 구성요소
- **MarkItDown 클래스**: 메인 오케스트레이터
- **DocumentConverter**: 변환기 기본 클래스
- **StreamInfo**: 파일 메타데이터 관리
- **Plugin System**: 확장 가능한 플러그인 아키텍처
- **MCP Server**: 단일 도구 인터페이스

## 2. 핵심 클래스 상세 분석

### 2.1 MarkItDown 클래스 (`_markitdown.py`)

```python
class MarkItDown:
    def __init__(self, 
                 enable_builtins: bool = True,
                 enable_plugins: bool = False,
                 llm_client=None,
                 llm_model: str = "gpt-4o",
                 docintel_endpoint: Optional[str] = None,
                 exiftool_path: Optional[str] = None,
                 style_map: Optional[str] = None):
        """
        핵심 메서드:
        - convert(): 범용 변환 메서드
        - convert_local(): 로컬 파일 변환
        - convert_stream(): 스트림 변환
        - convert_uri(): URI 변환
        - register_converter(): 변환기 등록
        """
```

**주요 기능:**
1. **변환기 관리**: 우선순위 기반 변환기 선택
2. **스트림 처리**: 메모리 효율적인 스트림 처리
3. **다중 힌트 시스템**: MIME 타입, 확장자, 내용 기반 추론
4. **플러그인 통합**: 동적 플러그인 로딩

### 2.2 DocumentConverter 기본 클래스 (`_base_converter.py`)

```python
class DocumentConverter:
    def accepts(self, file_stream: BinaryIO, stream_info: StreamInfo, **kwargs) -> bool:
        """파일 처리 가능 여부 판단"""
        raise NotImplementedError()
    
    def convert(self, file_stream: BinaryIO, stream_info: StreamInfo, **kwargs) -> DocumentConverterResult:
        """실제 변환 수행"""
        raise NotImplementedError()
    
    @property
    def priority(self) -> float:
        """변환기 우선순위 (낮을수록 높은 우선순위)"""
        return 0.0
```

**변환기 우선순위 시스템:**
- `PRIORITY_SPECIFIC_FILE_FORMAT = 0.0`: 특정 형식 전용 변환기
- `PRIORITY_GENERIC_FILE_FORMAT = 10.0`: 범용 변환기

### 2.3 StreamInfo 클래스 (`_stream_info.py`)

```python
class StreamInfo:
    def __init__(self, 
                 mimetype: Optional[str] = None,
                 extension: Optional[str] = None, 
                 charset: Optional[str] = None,
                 filename: Optional[str] = None,
                 local_path: Optional[str] = None,
                 url: Optional[str] = None):
        """
        파일 메타데이터 관리:
        - mimetype: MIME 타입 (예: application/pdf)
        - extension: 파일 확장자 (예: .pdf)
        - charset: 문자 인코딩 (예: utf-8)
        - filename: 원본 파일명
        - local_path: 로컬 파일 경로
        - url: 원본 URL
        """
```

## 3. 변환기 구현 패턴 분석

### 3.1 PDF 변환기 (`_converter_pdf.py`)

```python
class PdfConverter(DocumentConverter):
    def accepts(self, file_stream: BinaryIO, stream_info: StreamInfo, **kwargs) -> bool:
        return stream_info.mimetype == "application/pdf" or \
               stream_info.extension == ".pdf"
    
    def convert(self, file_stream: BinaryIO, stream_info: StreamInfo, **kwargs) -> DocumentConverterResult:
        # Azure Document Intelligence 우선 사용
        if self._docintel_endpoint:
            return self._convert_with_docintel(file_stream, stream_info)
        
        # 기본 pdfminer 사용
        return self._convert_with_pdfminer(file_stream, stream_info)
```

### 3.2 이미지 변환기 (`_converter_image.py`)

```python
class ImageConverter(DocumentConverter):
    def convert(self, file_stream: BinaryIO, stream_info: StreamInfo, **kwargs) -> DocumentConverterResult:
        # 1. EXIF 메타데이터 추출
        exif_data = self._extract_exif(file_stream)
        
        # 2. LLM을 사용한 이미지 설명 생성
        if self._llm_client:
            description = self._generate_description(file_stream)
        
        # 3. 마크다운 형식으로 결합
        markdown = self._format_markdown(exif_data, description)
        return DocumentConverterResult(markdown=markdown)
```

### 3.3 오디오 변환기 (`_converter_audio.py`)

```python
class AudioConverter(DocumentConverter):
    def convert(self, file_stream: BinaryIO, stream_info: StreamInfo, **kwargs) -> DocumentConverterResult:
        # 1. 오디오 메타데이터 추출
        metadata = self._extract_audio_metadata(file_stream)
        
        # 2. 음성 전사 (Speech Recognition)
        transcription = self._transcribe_audio(file_stream)
        
        # 3. 마크다운 형식으로 결합
        markdown = self._format_audio_markdown(metadata, transcription)
        return DocumentConverterResult(markdown=markdown)
```

## 4. 파일 형식 지원 분석

### 4.1 문서 형식
| 형식 | 변환기 | 주요 라이브러리 | 특징 |
|------|--------|-----------------|------|
| PDF | PdfConverter | pdfminer.six, Azure Document Intelligence | 텍스트 + 구조 보존 |
| DOCX | DocxConverter | mammoth, lxml | 스타일 매핑 지원 |
| PPTX | PptxConverter | python-pptx | 슬라이드별 처리 |
| XLSX/XLS | ExcelConverter | pandas, openpyxl/xlrd | 다중 시트 지원 |

### 4.2 웹 콘텐츠
| 형식 | 변환기 | 주요 라이브러리 | 특징 |
|------|--------|-----------------|------|
| HTML | HtmlConverter | beautifulsoup4, markdownify | 구조화된 HTML 처리 |
| RSS | RssConverter | feedparser | RSS 피드 파싱 |
| Wikipedia | WikipediaConverter | requests, beautifulsoup4 | 위키피디아 API 활용 |
| YouTube | YouTubeConverter | youtube-transcript-api | 자막 추출 |

### 4.3 미디어 파일
| 형식 | 변환기 | 주요 라이브러리 | 특징 |
|------|--------|-----------------|------|
| JPEG/PNG | ImageConverter | PIL, ExifTool | EXIF + LLM 설명 |
| MP3/WAV/M4A | AudioConverter | pydub, SpeechRecognition | 메타데이터 + 전사 |

### 4.4 데이터 형식
| 형식 | 변환기 | 주요 라이브러리 | 특징 |
|------|--------|-----------------|------|
| CSV | CsvConverter | pandas | 테이블 형식 변환 |
| JSON | JsonConverter | json | 구조화된 JSON 표현 |
| XML | XmlConverter | defusedxml | 안전한 XML 파싱 |
| ZIP | ZipConverter | zipfile | 재귀적 압축 해제 |

## 5. 스트림 처리 시스템 분석

### 5.1 스트림 처리 흐름
```python
def convert_stream(self, stream: BinaryIO, *, stream_info: Optional[StreamInfo] = None):
    # 1. 스트림을 seekable하게 만들기
    if not stream.seekable():
        buffer = io.BytesIO()
        shutil.copyfileobj(stream, buffer)
        stream = buffer
    
    # 2. 파일 타입 추론
    guesses = self._get_stream_info_guesses(stream, stream_info or StreamInfo())
    
    # 3. 변환 수행
    return self._convert(stream, guesses)
```

### 5.2 파일 타입 추론 시스템
```python
def _get_stream_info_guesses(self, file_stream: BinaryIO, base_guess: StreamInfo):
    # 1. Magika를 사용한 내용 기반 추론
    result = self._magika.identify_stream(file_stream)
    
    # 2. 확장자 기반 추론
    if base_guess.extension:
        extension_guess = self._guess_from_extension(base_guess.extension)
    
    # 3. MIME 타입 기반 추론
    if base_guess.mimetype:
        mimetype_guess = self._guess_from_mimetype(base_guess.mimetype)
    
    # 4. 우선순위 기반 정렬
    return sorted(guesses, key=lambda x: x.confidence, reverse=True)
```

## 6. 플러그인 시스템 분석

### 6.1 플러그인 로딩 메커니즘
```python
def _load_plugins():
    for entry_point in entry_points(group="markitdown.plugin"):
        try:
            plugin_converter = entry_point.load()
            _plugins.append(plugin_converter)
        except Exception as e:
            warn(f"Plugin '{entry_point.name}' failed to load: {e}")
```

### 6.2 플러그인 등록 방식
```python
# setup.py에서 플러그인 등록
entry_points={
    "markitdown.plugin": [
        "rtf = markitdown_sample_plugin:RtfConverter",
    ],
}
```

### 6.3 샘플 플러그인 구조
```python
class RtfConverter(DocumentConverter):
    def accepts(self, file_stream: BinaryIO, stream_info: StreamInfo, **kwargs) -> bool:
        return stream_info.extension == ".rtf"
    
    def convert(self, file_stream: BinaryIO, stream_info: StreamInfo, **kwargs) -> DocumentConverterResult:
        # RTF 파일 처리 로직
        pass
```

## 7. MCP 서버 구현 분석

### 7.1 MCP 서버 구조 (`markitdown-mcp/src/markitdown_mcp/server.py`)
```python
from mcp.server import Server
from mcp.types import Tool, TextContent

app = Server("markitdown")

@app.list_tools()
async def list_tools() -> list[Tool]:
    return [
        Tool(
            name="convert_to_markdown",
            description="Convert a resource to markdown",
            inputSchema={
                "type": "object",
                "properties": {
                    "uri": {
                        "type": "string",
                        "description": "URI (http:, https:, file:, or data:)"
                    }
                },
                "required": ["uri"]
            }
        )
    ]

@app.call_tool()
async def call_tool(name: str, arguments: dict) -> list[TextContent]:
    if name == "convert_to_markdown":
        uri = arguments["uri"]
        
        # 플러그인 활성화 여부 확인
        enable_plugins = os.environ.get("MARKITDOWN_ENABLE_PLUGINS", "false").lower() == "true"
        
        # MarkItDown 인스턴스 생성
        markitdown = MarkItDown(enable_plugins=enable_plugins)
        
        # 변환 수행
        result = markitdown.convert_uri(uri)
        
        return [TextContent(type="text", text=result.markdown)]
```

### 7.2 MCP 서버 특징
- **단일 도구**: `convert_to_markdown` 도구만 제공
- **URI 지원**: http, https, file, data URI 처리
- **환경 변수 제어**: 플러그인 활성화 제어
- **에러 처리**: 변환 실패시 적절한 에러 메시지 반환

## 8. 에러 처리 시스템 분석

### 8.1 예외 계층 구조
```python
class MarkItDownException(Exception):
    """기본 예외 클래스"""
    pass

class MissingDependencyException(MarkItDownException):
    """필수 의존성 누락"""
    pass

class UnsupportedFormatException(MarkItDownException):
    """지원하지 않는 파일 형식"""
    pass

class FileConversionException(MarkItDownException):
    """파일 변환 실패"""
    pass
```

### 8.2 에러 처리 패턴
```python
def _convert(self, file_stream: BinaryIO, stream_info_guesses: List[StreamInfo]):
    failed_converters = []
    
    for stream_info in stream_info_guesses:
        for converter_registration in self._converters:
            try:
                if converter_registration.converter.accepts(file_stream, stream_info):
                    return converter_registration.converter.convert(file_stream, stream_info)
            except Exception as e:
                failed_converters.append(FailedConversionAttempt(
                    converter=converter_registration.converter,
                    stream_info=stream_info,
                    exception=e
                ))
    
    # 모든 변환기 실패시 예외 발생
    raise UnsupportedFormatException(f"No converter found for {stream_info_guesses[0]}")
```

## 9. 테스트 시스템 분석

### 9.1 벡터 기반 테스트
```python
# _test_vectors.py
TEST_VECTORS = [
    {
        "name": "PDF with text",
        "input_file": "test_files/sample.pdf",
        "expected_output": "# Sample PDF\n\nThis is a sample PDF file...",
        "converter": "PdfConverter"
    },
    # ... 더 많은 테스트 벡터
]
```

### 9.2 테스트 실행 패턴
```python
@pytest.mark.parametrize("test_vector", TEST_VECTORS)
def test_conversion(test_vector):
    markitdown = MarkItDown()
    
    with open(test_vector["input_file"], "rb") as f:
        result = markitdown.convert_stream(f)
    
    assert result.markdown == test_vector["expected_output"]
```

## 10. 성능 최적화 요소

### 10.1 메모리 효율성
- **스트림 처리**: 파일 전체를 메모리에 로드하지 않음
- **지연 로딩**: 필요한 변환기만 로드
- **임시 파일 미사용**: 스트림 기반 처리

### 10.2 처리 속도 최적화
- **우선순위 기반 변환기 선택**: 가장 적합한 변환기 우선 시도
- **캐싱**: 반복 처리 최소화
- **병렬 처리**: 가능한 경우 병렬 처리 활용

## 11. 벤치마킹 포인트

### 11.1 복제해야 할 핵심 기능
1. **변환기 아키텍처**: 우선순위 기반 변환기 시스템
2. **스트림 처리**: 메모리 효율적인 파일 처리
3. **파일 타입 추론**: 다중 힌트 시스템
4. **플러그인 시스템**: 확장 가능한 아키텍처
5. **에러 처리**: 견고한 에러 처리 시스템

### 11.2 개선 가능한 영역
1. **한국어 지원**: 한국어 문서 처리 최적화
2. **추가 형식**: 더 많은 파일 형식 지원
3. **성능 향상**: 더 빠른 처리 속도
4. **메타데이터**: 더 풍부한 메타데이터 추출
5. **MCP 기능**: 더 많은 MCP 도구 제공

이 분석을 바탕으로 동일한 기능을 가진 MCP 서버를 구현하고, 점진적으로 업그레이드 기능을 추가할 수 있습니다.