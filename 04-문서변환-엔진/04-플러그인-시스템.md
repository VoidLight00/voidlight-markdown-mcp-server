# 플러그인 시스템 구현

## 1. 플러그인 관리자

### 1.1 플러그인 매니저
```python
# src/markitdown_mcp_enhanced/plugins/plugin_manager.py
import importlib
import sys
from typing import List, Dict, Any, Optional, Type
from pathlib import Path
import logging

from ..core.base_converter import DocumentConverter
from ..core.exceptions import MarkItDownException
from ..config.logging_config import setup_logging

logger = setup_logging()

class PluginManager:
    """플러그인 관리자"""
    
    def __init__(self):
        self.plugins: List[DocumentConverter] = []
        self.plugin_metadata: Dict[str, Dict[str, Any]] = {}
        
    def load_plugins(self) -> List[DocumentConverter]:
        """플러그인 로드"""
        plugins = []
        
        # entry_points에서 플러그인 로드
        entry_point_plugins = self._load_entry_point_plugins()
        plugins.extend(entry_point_plugins)
        
        # 로컬 플러그인 디렉터리에서 로드
        local_plugins = self._load_local_plugins()
        plugins.extend(local_plugins)
        
        # 환경 변수에서 지정된 플러그인 로드
        env_plugins = self._load_environment_plugins()
        plugins.extend(env_plugins)
        
        self.plugins = plugins
        return plugins
    
    def _load_entry_point_plugins(self) -> List[DocumentConverter]:
        """entry_points에서 플러그인 로드"""
        plugins = []
        
        try:
            # Python 3.10+
            from importlib.metadata import entry_points
        except ImportError:
            # Python < 3.10
            from importlib_metadata import entry_points
        
        try:
            eps = entry_points(group="markitdown.plugin")
            for ep in eps:
                try:
                    plugin_class = ep.load()
                    if self._validate_plugin(plugin_class):
                        plugin_instance = plugin_class()
                        plugins.append(plugin_instance)
                        
                        # 메타데이터 저장
                        self.plugin_metadata[ep.name] = {
                            'name': ep.name,
                            'module': ep.module,
                            'class': plugin_class.__name__,
                            'source': 'entry_point'
                        }
                        
                        logger.info(f"Loaded entry point plugin: {ep.name}")
                    else:
                        logger.warning(f"Invalid plugin: {ep.name}")
                        
                except Exception as e:
                    logger.error(f"Failed to load entry point plugin {ep.name}: {e}")
                    
        except Exception as e:
            logger.debug(f"Entry point plugin loading failed: {e}")
        
        return plugins
    
    def _load_local_plugins(self) -> List[DocumentConverter]:
        """로컬 플러그인 디렉터리에서 로드"""
        plugins = []
        
        # 플러그인 디렉터리 확인
        plugin_dir = Path(__file__).parent
        
        for plugin_file in plugin_dir.glob("*_plugin.py"):
            if plugin_file.stem == "__init__":
                continue
                
            try:
                # 모듈 로드
                module_name = f"markitdown_mcp_enhanced.plugins.{plugin_file.stem}"
                
                if module_name in sys.modules:
                    module = sys.modules[module_name]
                    importlib.reload(module)
                else:
                    module = importlib.import_module(module_name)
                
                # 플러그인 클래스 찾기
                plugin_classes = self._find_plugin_classes(module)
                
                for plugin_class in plugin_classes:
                    if self._validate_plugin(plugin_class):
                        plugin_instance = plugin_class()
                        plugins.append(plugin_instance)
                        
                        # 메타데이터 저장
                        self.plugin_metadata[plugin_class.__name__] = {
                            'name': plugin_class.__name__,
                            'module': module_name,
                            'class': plugin_class.__name__,
                            'source': 'local',
                            'file': str(plugin_file)
                        }
                        
                        logger.info(f"Loaded local plugin: {plugin_class.__name__}")
                        
            except Exception as e:
                logger.error(f"Failed to load local plugin {plugin_file}: {e}")
        
        return plugins
    
    def _load_environment_plugins(self) -> List[DocumentConverter]:
        """환경 변수에서 지정된 플러그인 로드"""
        plugins = []
        
        import os
        plugin_paths = os.getenv("MARKITDOWN_PLUGINS", "").split(",")
        
        for plugin_path in plugin_paths:
            plugin_path = plugin_path.strip()
            if not plugin_path:
                continue
                
            try:
                # 모듈 경로 분석
                if ":" in plugin_path:
                    module_path, class_name = plugin_path.split(":", 1)
                else:
                    module_path = plugin_path
                    class_name = None
                
                # 모듈 로드
                module = importlib.import_module(module_path)
                
                # 클래스 찾기
                if class_name:
                    plugin_class = getattr(module, class_name)
                    plugin_classes = [plugin_class]
                else:
                    plugin_classes = self._find_plugin_classes(module)
                
                for plugin_class in plugin_classes:
                    if self._validate_plugin(plugin_class):
                        plugin_instance = plugin_class()
                        plugins.append(plugin_instance)
                        
                        # 메타데이터 저장
                        self.plugin_metadata[plugin_class.__name__] = {
                            'name': plugin_class.__name__,
                            'module': module_path,
                            'class': plugin_class.__name__,
                            'source': 'environment',
                            'path': plugin_path
                        }
                        
                        logger.info(f"Loaded environment plugin: {plugin_class.__name__}")
                        
            except Exception as e:
                logger.error(f"Failed to load environment plugin {plugin_path}: {e}")
        
        return plugins
    
    def _find_plugin_classes(self, module) -> List[Type[DocumentConverter]]:
        """모듈에서 플러그인 클래스 찾기"""
        plugin_classes = []
        
        for name in dir(module):
            obj = getattr(module, name)
            
            # 클래스이고 DocumentConverter를 상속받는지 확인
            if (isinstance(obj, type) and 
                issubclass(obj, DocumentConverter) and 
                obj is not DocumentConverter):
                plugin_classes.append(obj)
        
        return plugin_classes
    
    def _validate_plugin(self, plugin_class: Type[DocumentConverter]) -> bool:
        """플러그인 유효성 검사"""
        try:
            # DocumentConverter를 상속받는지 확인
            if not issubclass(plugin_class, DocumentConverter):
                return False
            
            # 필수 메서드가 구현되어 있는지 확인
            required_methods = ['accepts', 'convert']
            for method_name in required_methods:
                if not hasattr(plugin_class, method_name):
                    return False
                
                method = getattr(plugin_class, method_name)
                if not callable(method):
                    return False
            
            # 인스턴스 생성 테스트
            try:
                instance = plugin_class()
                # 기본 메서드 호출 테스트
                if hasattr(instance, 'get_format_info'):
                    instance.get_format_info()
            except Exception as e:
                logger.debug(f"Plugin instantiation test failed: {e}")
                return False
            
            return True
            
        except Exception as e:
            logger.debug(f"Plugin validation failed: {e}")
            return False
    
    def get_plugin_info(self) -> Dict[str, Dict[str, Any]]:
        """플러그인 정보 반환"""
        info = {}
        
        for plugin in self.plugins:
            class_name = plugin.__class__.__name__
            
            plugin_info = {
                'class': class_name,
                'priority': getattr(plugin, 'priority', 0.0),
                'supported_extensions': getattr(plugin, 'supported_extensions', []),
                'supported_mimetypes': getattr(plugin, 'supported_mimetypes', []),
                'category': getattr(plugin, 'category', 'unknown'),
                'description': plugin.__doc__ or 'No description'
            }
            
            # 메타데이터 추가
            if class_name in self.plugin_metadata:
                plugin_info.update(self.plugin_metadata[class_name])
            
            info[class_name] = plugin_info
        
        return info
    
    def reload_plugins(self) -> List[DocumentConverter]:
        """플러그인 다시 로드"""
        self.plugins.clear()
        self.plugin_metadata.clear()
        return self.load_plugins()
    
    def get_plugin_by_name(self, name: str) -> Optional[DocumentConverter]:
        """이름으로 플러그인 찾기"""
        for plugin in self.plugins:
            if plugin.__class__.__name__ == name:
                return plugin
        return None
    
    def get_plugins_by_category(self, category: str) -> List[DocumentConverter]:
        """카테고리별 플러그인 찾기"""
        plugins = []
        for plugin in self.plugins:
            if getattr(plugin, 'category', 'unknown') == category:
                plugins.append(plugin)
        return plugins
```

### 1.2 샘플 플러그인
```python
# src/markitdown_mcp_enhanced/plugins/sample_plugin.py
"""
샘플 플러그인 - RTF 파일 변환기
"""
import re
from typing import BinaryIO, Dict, Any, Optional
import logging

from ..core.base_converter import DocumentConverter, DocumentConverterResult
from ..core.stream_info import StreamInfo
from ..core.exceptions import MissingDependencyException, FileConversionException
from ..utils.stream_utils import read_stream_with_encoding
from ..utils.format_utils import normalize_whitespace

logger = logging.getLogger(__name__)

class RtfConverter(DocumentConverter):
    """RTF (Rich Text Format) 파일 변환기"""
    
    supported_extensions = ['.rtf']
    supported_mimetypes = ['application/rtf', 'text/rtf']
    category = 'documents'
    
    def __init__(self, korean_support: bool = True):
        super().__init__(korean_support=korean_support)
        self.priority = 0.5
        
        # 의존성 확인
        self._check_dependencies()
    
    def _check_dependencies(self):
        """의존성 확인"""
        try:
            import striprtf
            self.striprtf_available = True
        except ImportError:
            self.striprtf_available = False
    
    def accepts(self, file_stream: BinaryIO, stream_info: StreamInfo, **kwargs) -> bool:
        """RTF 파일 처리 가능 여부"""
        # MIME 타입 또는 확장자 확인
        if (stream_info.matches_mimetype(['application/rtf', 'text/rtf']) or
            stream_info.matches_extension(['.rtf'])):
            return True
        
        # 파일 내용 확인
        try:
            current_pos = file_stream.tell()
            file_stream.seek(0)
            header = file_stream.read(10).decode('utf-8', errors='ignore')
            file_stream.seek(current_pos)
            
            return header.startswith('{\\rtf')
        except:
            return False
    
    def convert(self, file_stream: BinaryIO, stream_info: StreamInfo, **kwargs) -> DocumentConverterResult:
        """RTF 변환 수행"""
        logger.info(f"Converting RTF: {stream_info.filename}")
        
        try:
            # RTF 내용 읽기
            rtf_content = read_stream_with_encoding(file_stream, stream_info.charset)
            
            # striprtf 사용 (가능한 경우)
            if self.striprtf_available:
                text = self._convert_with_striprtf(rtf_content)
            else:
                text = self._convert_with_regex(rtf_content)
            
            # 마크다운 변환
            markdown = self._text_to_markdown(text)
            
            # 메타데이터 추출
            metadata = self._extract_rtf_metadata(rtf_content, stream_info)
            
            # 제목 추출
            title = self._extract_title_from_text(text)
            
            return DocumentConverterResult(
                markdown=self._clean_markdown(markdown),
                title=title,
                metadata=metadata
            )
            
        except Exception as e:
            raise FileConversionException(f"RTF conversion failed: {e}")
    
    def _convert_with_striprtf(self, rtf_content: str) -> str:
        """striprtf 라이브러리로 변환"""
        from striprtf.striprtf import rtf_to_text
        return rtf_to_text(rtf_content)
    
    def _convert_with_regex(self, rtf_content: str) -> str:
        """정규식을 사용한 기본 RTF 변환"""
        # RTF 제어 문자 제거
        text = re.sub(r'\\[a-z]+\d*\s?', '', rtf_content)  # 제어 단어
        text = re.sub(r'\\[^a-z]', '', text)  # 제어 기호
        text = re.sub(r'[{}]', '', text)  # 중괄호
        
        # 불필요한 공백 정리
        text = normalize_whitespace(text)
        
        return text
    
    def _text_to_markdown(self, text: str) -> str:
        """텍스트를 마크다운으로 변환"""
        if not text:
            return ""
        
        # 단락 분리
        paragraphs = text.split('\n\n')
        
        markdown = ""
        for paragraph in paragraphs:
            paragraph = paragraph.strip()
            if not paragraph:
                continue
            
            # 제목 감지 (짧고 마침표가 없는 줄)
            if len(paragraph) < 100 and not paragraph.endswith('.'):
                markdown += f"## {paragraph}\n\n"
            else:
                markdown += f"{paragraph}\n\n"
        
        return markdown
    
    def _extract_rtf_metadata(self, rtf_content: str, stream_info: StreamInfo) -> Dict[str, Any]:
        """RTF 메타데이터 추출"""
        metadata = self._extract_metadata(None, stream_info)
        
        # RTF 정보 필드 추출
        info_fields = {
            '\\\\title': 'title',
            '\\\\author': 'author',
            '\\\\subject': 'subject',
            '\\\\keywords': 'keywords',
            '\\\\doccomm': 'comments',
            '\\\\company': 'company'
        }
        
        for rtf_field, meta_field in info_fields.items():
            pattern = rf'{rtf_field}\s+([^;}}]+)'
            match = re.search(pattern, rtf_content)
            if match:
                value = match.group(1).strip()
                if value:
                    metadata[meta_field] = value
        
        # 생성 시간 추출
        creatim_match = re.search(r'\\creatim\\yr(\d+)\\mo(\d+)\\dy(\d+)', rtf_content)
        if creatim_match:
            year, month, day = creatim_match.groups()
            metadata['creation_date'] = f"{year}-{month:0>2}-{day:0>2}"
        
        return metadata
    
    def _extract_title_from_text(self, text: str) -> Optional[str]:
        """텍스트에서 제목 추출"""
        if not text:
            return None
        
        lines = text.split('\n')
        for line in lines:
            line = line.strip()
            if line and len(line) < 100:
                return self._format_title(line)
        
        return None
    
    def get_format_info(self) -> Dict[str, Any]:
        """형식 정보 반환"""
        return {
            'name': 'RTF',
            'description': 'Rich Text Format 파일 변환기',
            'extensions': self.supported_extensions,
            'mimetypes': self.supported_mimetypes,
            'category': self.category,
            'dependencies': ['striprtf (optional)'],
            'features': [
                'RTF 제어 문자 제거',
                '기본 텍스트 추출',
                '메타데이터 추출',
                '한국어 지원'
            ]
        }
```

### 1.3 고급 플러그인 예시
```python
# src/markitdown_mcp_enhanced/plugins/advanced_plugin.py
"""
고급 플러그인 예시 - 다중 형식 지원
"""
import mimetypes
from typing import BinaryIO, Dict, Any, Optional, List
import logging

from ..core.base_converter import DocumentConverter, DocumentConverterResult
from ..core.stream_info import StreamInfo
from ..core.exceptions import FileConversionException
from ..utils.stream_utils import read_stream_with_encoding
from ..utils.format_utils import normalize_whitespace, create_markdown_table

logger = logging.getLogger(__name__)

class AdvancedTextConverter(DocumentConverter):
    """고급 텍스트 변환기 - 다양한 텍스트 형식 지원"""
    
    supported_extensions = ['.txt', '.log', '.cfg', '.ini', '.conf', '.md', '.rst', '.tex']
    supported_mimetypes = ['text/plain', 'text/x-log', 'text/markdown', 'text/x-rst']
    category = 'documents'
    
    def __init__(self, korean_support: bool = True):
        super().__init__(korean_support=korean_support)
        self.priority = 5.0  # 낮은 우선순위 (다른 전문 변환기 이후)
        
        # 파일 유형별 처리 방법 설정
        self.format_handlers = {
            '.log': self._handle_log_file,
            '.cfg': self._handle_config_file,
            '.ini': self._handle_ini_file,
            '.conf': self._handle_config_file,
            '.md': self._handle_markdown_file,
            '.rst': self._handle_rst_file,
            '.tex': self._handle_latex_file,
            '.txt': self._handle_plain_text
        }
    
    def accepts(self, file_stream: BinaryIO, stream_info: StreamInfo, **kwargs) -> bool:
        """텍스트 파일 처리 가능 여부"""
        # 확장자 확인
        if stream_info.matches_extension(self.supported_extensions):
            return True
        
        # MIME 타입 확인
        if stream_info.matches_mimetype(self.supported_mimetypes):
            return True
        
        # 파일 내용 확인 (텍스트 파일인지)
        try:
            current_pos = file_stream.tell()
            file_stream.seek(0)
            sample = file_stream.read(8192)
            file_stream.seek(current_pos)
            
            # 텍스트 파일인지 확인
            try:
                sample.decode('utf-8')
                return True
            except UnicodeDecodeError:
                # 다른 인코딩 시도
                for encoding in ['cp949', 'euc-kr', 'latin1']:
                    try:
                        sample.decode(encoding)
                        return True
                    except UnicodeDecodeError:
                        continue
        except:
            pass
        
        return False
    
    def convert(self, file_stream: BinaryIO, stream_info: StreamInfo, **kwargs) -> DocumentConverterResult:
        """텍스트 변환 수행"""
        logger.info(f"Converting text file: {stream_info.filename}")
        
        try:
            # 텍스트 내용 읽기
            text_content = read_stream_with_encoding(file_stream, stream_info.charset)
            
            # 파일 형식별 처리
            extension = stream_info.extension or '.txt'
            handler = self.format_handlers.get(extension, self._handle_plain_text)
            
            result = handler(text_content, stream_info)
            
            return DocumentConverterResult(
                markdown=self._clean_markdown(result['markdown']),
                title=result.get('title'),
                metadata=result.get('metadata', {})
            )
            
        except Exception as e:
            raise FileConversionException(f"Text conversion failed: {e}")
    
    def _handle_plain_text(self, content: str, stream_info: StreamInfo) -> Dict[str, Any]:
        """일반 텍스트 처리"""
        # 단락 분리
        paragraphs = content.split('\n\n')
        
        markdown = ""
        for paragraph in paragraphs:
            paragraph = paragraph.strip()
            if paragraph:
                markdown += f"{paragraph}\n\n"
        
        return {
            'markdown': markdown,
            'title': self._extract_title_from_filename(stream_info.filename),
            'metadata': self._extract_metadata(None, stream_info)
        }
    
    def _handle_log_file(self, content: str, stream_info: StreamInfo) -> Dict[str, Any]:
        """로그 파일 처리"""
        lines = content.split('\n')
        
        markdown = f"# 로그 파일: {stream_info.filename or 'Unknown'}\n\n"
        
        # 로그 레벨별 분류
        log_levels = {'ERROR': [], 'WARN': [], 'INFO': [], 'DEBUG': []}
        other_lines = []
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
            
            # 로그 레벨 감지
            level_found = False
            for level in log_levels:
                if level in line.upper():
                    log_levels[level].append(line)
                    level_found = True
                    break
            
            if not level_found:
                other_lines.append(line)
        
        # 로그 레벨별 섹션 생성
        for level, level_lines in log_levels.items():
            if level_lines:
                markdown += f"## {level} 로그\n\n"
                for line in level_lines[:20]:  # 최대 20개만 표시
                    markdown += f"```\n{line}\n```\n\n"
                
                if len(level_lines) > 20:
                    markdown += f"*... 및 {len(level_lines) - 20}개 더*\n\n"
        
        # 기타 로그
        if other_lines:
            markdown += "## 기타 로그\n\n"
            for line in other_lines[:10]:  # 최대 10개만 표시
                markdown += f"```\n{line}\n```\n\n"
        
        # 통계 정보
        metadata = self._extract_metadata(None, stream_info)
        metadata.update({
            'total_lines': len(lines),
            'error_count': len(log_levels['ERROR']),
            'warning_count': len(log_levels['WARN']),
            'info_count': len(log_levels['INFO']),
            'debug_count': len(log_levels['DEBUG'])
        })
        
        return {
            'markdown': markdown,
            'title': f"로그 파일: {stream_info.filename or 'Unknown'}",
            'metadata': metadata
        }
    
    def _handle_config_file(self, content: str, stream_info: StreamInfo) -> Dict[str, Any]:
        """설정 파일 처리"""
        lines = content.split('\n')
        
        markdown = f"# 설정 파일: {stream_info.filename or 'Unknown'}\n\n"
        
        current_section = None
        sections = {}
        
        for line in lines:
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            
            # 섹션 헤더 감지 ([section])
            if line.startswith('[') and line.endswith(']'):
                current_section = line[1:-1]
                sections[current_section] = []
            elif current_section and '=' in line:
                key, value = line.split('=', 1)
                sections[current_section].append({
                    'key': key.strip(),
                    'value': value.strip()
                })
        
        # 섹션별 테이블 생성
        for section_name, settings in sections.items():
            markdown += f"## {section_name}\n\n"
            
            if settings:
                headers = ['설정', '값']
                rows = [[setting['key'], setting['value']] for setting in settings]
                markdown += create_markdown_table(headers, rows)
                markdown += "\n"
        
        return {
            'markdown': markdown,
            'title': f"설정 파일: {stream_info.filename or 'Unknown'}",
            'metadata': self._extract_metadata(None, stream_info)
        }
    
    def _handle_ini_file(self, content: str, stream_info: StreamInfo) -> Dict[str, Any]:
        """INI 파일 처리"""
        return self._handle_config_file(content, stream_info)
    
    def _handle_markdown_file(self, content: str, stream_info: StreamInfo) -> Dict[str, Any]:
        """마크다운 파일 처리 (그대로 반환)"""
        return {
            'markdown': content,
            'title': self._extract_title_from_markdown(content),
            'metadata': self._extract_metadata(None, stream_info)
        }
    
    def _handle_rst_file(self, content: str, stream_info: StreamInfo) -> Dict[str, Any]:
        """reStructuredText 파일 처리"""
        # 기본적인 RST -> Markdown 변환
        lines = content.split('\n')
        markdown = ""
        
        for i, line in enumerate(lines):
            line = line.strip()
            if not line:
                markdown += "\n"
                continue
            
            # 제목 감지 (다음 줄이 =, -, ~ 등으로 구성된 경우)
            if i + 1 < len(lines):
                next_line = lines[i + 1].strip()
                if next_line and all(c in '=-~`#' for c in next_line) and len(next_line) >= len(line):
                    # 제목 레벨 결정
                    if '=' in next_line:
                        level = 1
                    elif '-' in next_line:
                        level = 2
                    elif '~' in next_line:
                        level = 3
                    else:
                        level = 4
                    
                    markdown += f"{'#' * level} {line}\n\n"
                    continue
            
            # 일반 텍스트
            markdown += f"{line}\n"
        
        return {
            'markdown': markdown,
            'title': self._extract_title_from_rst(content),
            'metadata': self._extract_metadata(None, stream_info)
        }
    
    def _handle_latex_file(self, content: str, stream_info: StreamInfo) -> Dict[str, Any]:
        """LaTeX 파일 처리"""
        import re
        
        # 기본적인 LaTeX -> Markdown 변환
        markdown = content
        
        # 제목 변환
        markdown = re.sub(r'\\title\{([^}]+)\}', r'# \1', markdown)
        markdown = re.sub(r'\\section\{([^}]+)\}', r'## \1', markdown)
        markdown = re.sub(r'\\subsection\{([^}]+)\}', r'### \1', markdown)
        markdown = re.sub(r'\\subsubsection\{([^}]+)\}', r'#### \1', markdown)
        
        # 강조 변환
        markdown = re.sub(r'\\textbf\{([^}]+)\}', r'**\1**', markdown)
        markdown = re.sub(r'\\textit\{([^}]+)\}', r'*\1*', markdown)
        markdown = re.sub(r'\\emph\{([^}]+)\}', r'*\1*', markdown)
        
        # 불필요한 LaTeX 명령 제거
        markdown = re.sub(r'\\[a-zA-Z]+\*?(\[[^\]]*\])?(\{[^}]*\})*', '', markdown)
        
        # 공백 정리
        markdown = normalize_whitespace(markdown)
        
        return {
            'markdown': markdown,
            'title': self._extract_title_from_latex(content),
            'metadata': self._extract_metadata(None, stream_info)
        }
    
    def _extract_title_from_filename(self, filename: Optional[str]) -> Optional[str]:
        """파일명에서 제목 추출"""
        if not filename:
            return None
        
        # 확장자 제거
        title = filename
        if '.' in title:
            title = title.rsplit('.', 1)[0]
        
        # 언더스코어와 하이픈을 공백으로 변환
        title = title.replace('_', ' ').replace('-', ' ')
        
        return self._format_title(title)
    
    def _extract_title_from_markdown(self, content: str) -> Optional[str]:
        """마크다운에서 제목 추출"""
        import re
        
        # 첫 번째 헤딩 찾기
        match = re.search(r'^#\s+(.+)$', content, re.MULTILINE)
        if match:
            return self._format_title(match.group(1))
        
        return None
    
    def _extract_title_from_rst(self, content: str) -> Optional[str]:
        """RST에서 제목 추출"""
        lines = content.split('\n')
        
        for i, line in enumerate(lines):
            line = line.strip()
            if not line:
                continue
            
            # 다음 줄이 제목 구분선인지 확인
            if i + 1 < len(lines):
                next_line = lines[i + 1].strip()
                if next_line and all(c in '=-~`#' for c in next_line) and len(next_line) >= len(line):
                    return self._format_title(line)
        
        return None
    
    def _extract_title_from_latex(self, content: str) -> Optional[str]:
        """LaTeX에서 제목 추출"""
        import re
        
        # \title{} 명령 찾기
        match = re.search(r'\\title\{([^}]+)\}', content)
        if match:
            return self._format_title(match.group(1))
        
        return None
    
    def get_format_info(self) -> Dict[str, Any]:
        """형식 정보 반환"""
        return {
            'name': 'AdvancedText',
            'description': '고급 텍스트 파일 변환기 (로그, 설정, 마크다운, RST, LaTeX 등)',
            'extensions': self.supported_extensions,
            'mimetypes': self.supported_mimetypes,
            'category': self.category,
            'features': [
                '다중 텍스트 형식 지원',
                '로그 파일 분석',
                '설정 파일 구조화',
                'RST -> Markdown 변환',
                'LaTeX -> Markdown 변환',
                '한국어 지원',
                '자동 인코딩 감지'
            ],
            'supported_formats': {
                '.log': '로그 파일 분석 및 레벨별 분류',
                '.cfg/.ini/.conf': '설정 파일 구조화',
                '.md': '마크다운 파일 (그대로 유지)',
                '.rst': 'reStructuredText -> Markdown 변환',
                '.tex': 'LaTeX -> Markdown 변환',
                '.txt': '일반 텍스트 파일'
            }
        }
```

### 1.4 플러그인 초기화 파일
```python
# src/markitdown_mcp_enhanced/plugins/__init__.py
"""
플러그인 시스템 초기화
"""
from .plugin_manager import PluginManager
from .sample_plugin import RtfConverter
from .advanced_plugin import AdvancedTextConverter

__all__ = [
    'PluginManager',
    'RtfConverter', 
    'AdvancedTextConverter'
]

# 기본 플러그인 목록
DEFAULT_PLUGINS = [
    RtfConverter,
    AdvancedTextConverter
]
```

## 2. 플러그인 등록 및 배포

### 2.1 setup.py 설정 예시
```python
# setup.py (플러그인 배포용)
from setuptools import setup, find_packages

setup(
    name="markitdown-mcp-enhanced-plugins",
    version="1.0.0",
    description="Additional plugins for MarkItDown MCP Enhanced",
    author="Your Name",
    author_email="your.email@example.com",
    packages=find_packages(),
    install_requires=[
        "markitdown-mcp-enhanced>=1.0.0",
        "striprtf>=0.0.21",  # RTF 플러그인용
    ],
    entry_points={
        "markitdown.plugin": [
            "rtf = markitdown_mcp_enhanced_plugins.rtf_plugin:RtfConverter",
            "advanced_text = markitdown_mcp_enhanced_plugins.advanced_text_plugin:AdvancedTextConverter",
        ],
    },
    python_requires=">=3.10",
    classifiers=[
        "Development Status :: 4 - Beta",
        "Intended Audience :: Developers",
        "License :: OSI Approved :: MIT License",
        "Programming Language :: Python :: 3.10",
        "Programming Language :: Python :: 3.11",
        "Programming Language :: Python :: 3.12",
    ],
)
```

### 2.2 플러그인 개발 가이드
```markdown
# 플러그인 개발 가이드

## 1. 기본 플러그인 구조

```python
from markitdown_mcp_enhanced.core.base_converter import DocumentConverter, DocumentConverterResult
from markitdown_mcp_enhanced.core.stream_info import StreamInfo

class MyConverter(DocumentConverter):
    supported_extensions = ['.myext']
    supported_mimetypes = ['application/my-format']
    category = 'documents'
    
    def __init__(self, korean_support: bool = True):
        super().__init__(korean_support=korean_support)
        self.priority = 1.0
    
    def accepts(self, file_stream, stream_info, **kwargs):
        # 파일 처리 가능 여부 판단
        return stream_info.matches_extension(self.supported_extensions)
    
    def convert(self, file_stream, stream_info, **kwargs):
        # 실제 변환 수행
        content = self._extract_content(file_stream)
        markdown = self._convert_to_markdown(content)
        
        return DocumentConverterResult(
            markdown=markdown,
            title=self._extract_title(content),
            metadata=self._extract_metadata(file_stream, stream_info)
        )
```

## 2. 플러그인 등록 방법

### entry_points 사용
```python
# setup.py
entry_points={
    "markitdown.plugin": [
        "my_converter = my_plugin:MyConverter",
    ],
}
```

### 환경 변수 사용
```bash
export MARKITDOWN_PLUGINS="my_plugin:MyConverter,another_plugin:AnotherConverter"
```

### 로컬 플러그인
플러그인 디렉터리에 `*_plugin.py` 파일 생성

## 3. 플러그인 테스트

```python
import pytest
from markitdown_mcp_enhanced.core.stream_info import StreamInfo
from my_plugin import MyConverter

def test_my_converter():
    converter = MyConverter()
    
    # 파일 타입 확인 테스트
    stream_info = StreamInfo(extension='.myext')
    assert converter.accepts(None, stream_info)
    
    # 변환 테스트
    with open('test.myext', 'rb') as f:
        result = converter.convert(f, stream_info)
        assert result.markdown
        assert result.title
```

## 4. 플러그인 배포

```bash
# 패키지 빌드
python setup.py sdist bdist_wheel

# PyPI 업로드
twine upload dist/*
```
```

<function_calls>
<invoke name="TodoWrite">
<parameter name="todos">[{"content": "MCP \uc11c\ubc84 \uad6c\ucd95 \ud3f4\ub354 \ubc0f \ud558\uc704\uad6c\uc870 \uc0dd\uc131", "status": "completed", "priority": "high", "id": "30"}, {"content": "markitdown GitHub \ub9ac\ud3ec\uc9c0\ud1a0\ub9ac \ubd84\uc11d", "status": "completed", "priority": "high", "id": "31"}, {"content": "markitdown MCP \uc11c\ubc84 \uae30\ub2a5 \ubca4\uce58\ub9c8\ud0b9", "status": "completed", "priority": "high", "id": "32"}, {"content": "\ub3d9\uc77c \uae30\ub2a5 MCP \uc11c\ubc84 \uad6c\ud604", "status": "completed", "priority": "high", "id": "33"}, {"content": "\uc5c5\uadf8\ub808\uc774\ub4dc \ubc84\uc804 \uae30\ub2a5 \uc124\uacc4", "status": "pending", "priority": "medium", "id": "34"}, {"content": "\ud578\uc2ec \ubcc0\ud658 \uc5d4\uc9c4 \uad6c\ud604", "status": "completed", "priority": "high", "id": "35"}, {"content": "\uae30\ubcf8 \ubcc0\ud658\uae30 \uc2dc\uc2a4\ud15c \uad6c\ud604", "status": "completed", "priority": "high", "id": "36"}, {"content": "\ud50c\ub7ec\uadf8\uc778 \uc2dc\uc2a4\ud15c \uad6c\ud604", "status": "completed", "priority": "medium", "id": "37"}, {"content": "PDF \ubcc0\ud658\uae30 \uad6c\ud604", "status": "completed", "priority": "high", "id": "38"}, {"content": "DOCX \ubcc0\ud658\uae30 \uad6c\ud604", "status": "completed", "priority": "high", "id": "39"}, {"content": "\uc774\ubbf8\uc9c0 \ubcc0\ud658\uae30 \uad6c\ud604", "status": "completed", "priority": "high", "id": "40"}, {"content": "\uc624\ub514\uc624 \ubcc0\ud658\uae30 \uad6c\ud604", "status": "completed", "priority": "high", "id": "41"}, {"content": "HTML \ubcc0\ud658\uae30 \uad6c\ud604", "status": "completed", "priority": "medium", "id": "42"}, {"content": "\uc720\ud2f8\ub9ac\ud2f0 \ubaa8\ub4c8 \uad6c\ud604", "status": "completed", "priority": "medium", "id": "43"}]