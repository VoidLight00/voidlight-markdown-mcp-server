# 문서 변환 엔진 아키텍처

## 1. 핵심 변환 엔진 구현

### 1.1 MarkItDown 메인 클래스
```python
# src/markitdown_mcp_enhanced/core/markitdown.py
import io
import shutil
from typing import List, Optional, Dict, Any, BinaryIO, Union
from pathlib import Path
import requests
from concurrent.futures import ThreadPoolExecutor

from .base_converter import DocumentConverter, DocumentConverterResult
from .stream_info import StreamInfo
from .exceptions import MarkItDownException, UnsupportedFormatException
from ..utils.file_detector import FileTypeDetector
from ..utils.stream_utils import make_stream_seekable
from ..plugins.plugin_manager import PluginManager
from ..config.logging_config import setup_logging

logger = setup_logging()

class MarkItDown:
    """Enhanced MarkItDown with Korean support and additional features"""
    
    def __init__(self, 
                 enable_builtins: bool = True,
                 enable_plugins: bool = True,
                 llm_client=None,
                 llm_model: str = "gpt-4o",
                 docintel_endpoint: Optional[str] = None,
                 exiftool_path: Optional[str] = None,
                 enable_korean_support: bool = True,
                 max_workers: int = 4):
        
        self.enable_builtins = enable_builtins
        self.enable_plugins = enable_plugins
        self.llm_client = llm_client
        self.llm_model = llm_model
        self.docintel_endpoint = docintel_endpoint
        self.exiftool_path = exiftool_path
        self.enable_korean_support = enable_korean_support
        self.max_workers = max_workers
        
        # 변환기 등록 리스트
        self._converters: List[ConverterRegistration] = []
        
        # 유틸리티 초기화
        self._file_detector = FileTypeDetector()
        self._plugin_manager = PluginManager() if enable_plugins else None
        
        # 옵션 설정
        self._options = {
            'include_metadata': False,
            'extract_images': False,
            'korean_optimization': False
        }
        
        # 변환기 등록
        self._register_converters()
        
        # 플러그인 로드
        if enable_plugins and self._plugin_manager:
            self._load_plugins()
    
    def _register_converters(self):
        """기본 변환기 등록"""
        if not self.enable_builtins:
            return
        
        # 변환기들을 우선순위 순으로 등록
        from ..converters import (
            PdfConverter, DocxConverter, PptxConverter, ExcelConverter,
            ImageConverter, AudioConverter, HtmlConverter, TextConverter,
            JsonConverter, XmlConverter, CsvConverter, ZipConverter,
            EpubConverter, RssConverter, WikipediaConverter, YoutubeConverter
        )
        
        # 특정 형식 변환기 (높은 우선순위)
        self.register_converter(PdfConverter(
            docintel_endpoint=self.docintel_endpoint,
            korean_support=self.enable_korean_support
        ), priority=0.0)
        
        self.register_converter(DocxConverter(
            korean_support=self.enable_korean_support
        ), priority=0.1)
        
        self.register_converter(PptxConverter(
            korean_support=self.enable_korean_support
        ), priority=0.2)
        
        self.register_converter(ExcelConverter(
            korean_support=self.enable_korean_support
        ), priority=0.3)
        
        self.register_converter(ImageConverter(
            llm_client=self.llm_client,
            llm_model=self.llm_model,
            exiftool_path=self.exiftool_path,
            korean_support=self.enable_korean_support
        ), priority=1.0)
        
        self.register_converter(AudioConverter(
            korean_support=self.enable_korean_support
        ), priority=1.1)
        
        # 웹 콘텐츠 변환기
        self.register_converter(HtmlConverter(
            korean_support=self.enable_korean_support
        ), priority=2.0)
        
        self.register_converter(RssConverter(), priority=2.1)
        self.register_converter(WikipediaConverter(
            korean_support=self.enable_korean_support
        ), priority=2.2)
        self.register_converter(YoutubeConverter(
            korean_support=self.enable_korean_support
        ), priority=2.3)
        
        # 데이터 형식 변환기
        self.register_converter(JsonConverter(
            korean_support=self.enable_korean_support
        ), priority=3.0)
        self.register_converter(XmlConverter(
            korean_support=self.enable_korean_support
        ), priority=3.1)
        self.register_converter(CsvConverter(
            korean_support=self.enable_korean_support
        ), priority=3.2)
        
        # 아카이브 변환기
        self.register_converter(ZipConverter(
            markitdown_instance=self,
            korean_support=self.enable_korean_support
        ), priority=4.0)
        
        # 전자책 변환기
        self.register_converter(EpubConverter(
            korean_support=self.enable_korean_support
        ), priority=5.0)
        
        # 텍스트 변환기 (가장 낮은 우선순위)
        self.register_converter(TextConverter(
            korean_support=self.enable_korean_support
        ), priority=10.0)
    
    def _load_plugins(self):
        """플러그인 로드"""
        if not self._plugin_manager:
            return
        
        plugins = self._plugin_manager.load_plugins()
        for plugin in plugins:
            self.register_converter(plugin, priority=0.5)
            logger.info(f"Loaded plugin: {plugin.__class__.__name__}")
    
    def register_converter(self, converter: DocumentConverter, *, priority: float = 0.0):
        """변환기 등록"""
        registration = ConverterRegistration(
            converter=converter,
            priority=priority
        )
        
        # 우선순위 순으로 정렬하여 삽입
        insert_pos = 0
        for i, reg in enumerate(self._converters):
            if reg.priority > priority:
                insert_pos = i
                break
            insert_pos = i + 1
        
        self._converters.insert(insert_pos, registration)
        logger.debug(f"Registered converter: {converter.__class__.__name__} (priority: {priority})")
    
    def set_options(self, **kwargs):
        """옵션 설정"""
        self._options.update(kwargs)
    
    def convert(self, source: Union[str, Path, BinaryIO], **kwargs) -> DocumentConverterResult:
        """범용 변환 메서드"""
        if isinstance(source, (str, Path)):
            source_path = Path(source)
            if source_path.exists():
                return self.convert_local(source_path, **kwargs)
            else:
                # URL로 간주
                return self.convert_uri(str(source), **kwargs)
        
        elif hasattr(source, 'read'):
            return self.convert_stream(source, **kwargs)
        
        else:
            raise ValueError(f"Unsupported source type: {type(source)}")
    
    def convert_local(self, file_path: Union[str, Path], **kwargs) -> DocumentConverterResult:
        """로컬 파일 변환"""
        file_path = Path(file_path)
        
        if not file_path.exists():
            raise FileNotFoundError(f"File not found: {file_path}")
        
        # 파일 크기 확인
        if file_path.stat().st_size > 100 * 1024 * 1024:  # 100MB
            logger.warning(f"Large file detected: {file_path} ({file_path.stat().st_size} bytes)")
        
        # 스트림 정보 생성
        stream_info = StreamInfo(
            extension=file_path.suffix.lower(),
            filename=file_path.name,
            local_path=str(file_path)
        )
        
        # 파일 열기 및 변환
        with open(file_path, 'rb') as f:
            return self.convert_stream(f, stream_info=stream_info, **kwargs)
    
    def convert_stream(self, stream: BinaryIO, *, stream_info: Optional[StreamInfo] = None, **kwargs) -> DocumentConverterResult:
        """스트림 변환"""
        # 스트림을 seekable하게 만들기
        stream = make_stream_seekable(stream)
        
        # 스트림 정보 생성/업데이트
        if stream_info is None:
            stream_info = StreamInfo()
        
        # 파일 타입 추론
        stream_info_guesses = self._get_stream_info_guesses(stream, stream_info)
        
        # 변환 시도
        return self._convert_with_guesses(stream, stream_info_guesses, **kwargs)
    
    def convert_uri(self, uri: str, **kwargs) -> DocumentConverterResult:
        """URI 변환"""
        logger.info(f"Converting URI: {uri}")
        
        # URI 스키마 확인
        if uri.startswith('file://'):
            # 로컬 파일 URI
            file_path = uri[7:]  # 'file://' 제거
            return self.convert_local(file_path, **kwargs)
        
        elif uri.startswith('data:'):
            # 데이터 URI
            return self._convert_data_uri(uri, **kwargs)
        
        elif uri.startswith(('http://', 'https://')):
            # HTTP/HTTPS URI
            return self._convert_http_uri(uri, **kwargs)
        
        else:
            # 로컬 파일 경로로 간주
            return self.convert_local(uri, **kwargs)
    
    def _convert_data_uri(self, data_uri: str, **kwargs) -> DocumentConverterResult:
        """데이터 URI 변환"""
        import base64
        from urllib.parse import unquote
        
        # 데이터 URI 파싱
        if not data_uri.startswith('data:'):
            raise ValueError("Invalid data URI")
        
        # 헤더와 데이터 분리
        header, data = data_uri[5:].split(',', 1)
        
        # 미디어 타입 추출
        if ';' in header:
            media_type, encoding = header.split(';', 1)
            is_base64 = 'base64' in encoding
        else:
            media_type = header
            is_base64 = False
        
        # 데이터 디코딩
        if is_base64:
            binary_data = base64.b64decode(data)
        else:
            binary_data = unquote(data).encode('utf-8')
        
        # 스트림 생성
        stream = io.BytesIO(binary_data)
        stream_info = StreamInfo(mimetype=media_type)
        
        return self.convert_stream(stream, stream_info=stream_info, **kwargs)
    
    def _convert_http_uri(self, uri: str, **kwargs) -> DocumentConverterResult:
        """HTTP/HTTPS URI 변환"""
        try:
            # HTTP 요청
            response = requests.get(uri, stream=True, timeout=30)
            response.raise_for_status()
            
            # 스트림 정보 생성
            stream_info = StreamInfo(
                mimetype=response.headers.get('content-type'),
                url=uri,
                charset=response.encoding
            )
            
            # Content-Disposition에서 파일명 추출
            content_disposition = response.headers.get('content-disposition')
            if content_disposition:
                filename = self._extract_filename_from_disposition(content_disposition)
                if filename:
                    stream_info.filename = filename
                    stream_info.extension = Path(filename).suffix.lower()
            
            # 스트림 변환
            return self.convert_stream(response.raw, stream_info=stream_info, **kwargs)
        
        except requests.RequestException as e:
            raise MarkItDownException(f"Failed to fetch URI {uri}: {e}")
    
    def _extract_filename_from_disposition(self, disposition: str) -> Optional[str]:
        """Content-Disposition에서 파일명 추출"""
        import re
        
        # filename* 형식 (RFC 5987)
        match = re.search(r"filename\*=(?:UTF-8'')?([^;]+)", disposition)
        if match:
            from urllib.parse import unquote
            return unquote(match.group(1))
        
        # filename 형식
        match = re.search(r'filename="([^"]+)"', disposition)
        if match:
            return match.group(1)
        
        match = re.search(r'filename=([^;]+)', disposition)
        if match:
            return match.group(1).strip()
        
        return None
    
    def _get_stream_info_guesses(self, stream: BinaryIO, base_info: StreamInfo) -> List[StreamInfo]:
        """스트림 정보 추론"""
        guesses = []
        
        # 1. 기본 정보 추가
        if base_info.mimetype or base_info.extension:
            guesses.append(base_info)
        
        # 2. 파일 내용 기반 추론
        content_guess = self._file_detector.detect_from_stream(stream)
        if content_guess and content_guess not in guesses:
            guesses.append(content_guess)
        
        # 3. 파일명 기반 추론
        if base_info.filename:
            filename_guess = self._file_detector.detect_from_filename(base_info.filename)
            if filename_guess and filename_guess not in guesses:
                guesses.append(filename_guess)
        
        # 4. 확장자 기반 추론
        if base_info.extension:
            extension_guess = self._file_detector.detect_from_extension(base_info.extension)
            if extension_guess and extension_guess not in guesses:
                guesses.append(extension_guess)
        
        # 5. MIME 타입 기반 추론
        if base_info.mimetype:
            mimetype_guess = self._file_detector.detect_from_mimetype(base_info.mimetype)
            if mimetype_guess and mimetype_guess not in guesses:
                guesses.append(mimetype_guess)
        
        return guesses or [StreamInfo()]
    
    def _convert_with_guesses(self, stream: BinaryIO, 
                            stream_info_guesses: List[StreamInfo], 
                            **kwargs) -> DocumentConverterResult:
        """추론된 정보로 변환 시도"""
        
        failed_attempts = []
        
        for stream_info in stream_info_guesses:
            for converter_reg in self._converters:
                converter = converter_reg.converter
                
                try:
                    # 변환기가 파일을 처리할 수 있는지 확인
                    if converter.accepts(stream, stream_info, **kwargs):
                        logger.debug(f"Trying converter: {converter.__class__.__name__}")
                        
                        # 변환 수행
                        result = converter.convert(stream, stream_info, **kwargs)
                        
                        # 결과 후처리
                        if self._options.get('korean_optimization'):
                            result = self._apply_korean_optimization(result)
                        
                        logger.info(f"Successfully converted with {converter.__class__.__name__}")
                        return result
                
                except Exception as e:
                    failed_attempts.append({
                        'converter': converter.__class__.__name__,
                        'stream_info': stream_info,
                        'error': str(e)
                    })
                    logger.debug(f"Converter {converter.__class__.__name__} failed: {e}")
        
        # 모든 변환기 실패
        error_msg = f"No suitable converter found for stream"
        if stream_info_guesses:
            error_msg += f" (guessed types: {[str(si) for si in stream_info_guesses]})"
        
        if failed_attempts:
            error_msg += f"\nFailed attempts: {failed_attempts}"
        
        raise UnsupportedFormatException(error_msg)
    
    def _apply_korean_optimization(self, result: DocumentConverterResult) -> DocumentConverterResult:
        """한국어 최적화 적용"""
        if not self.enable_korean_support:
            return result
        
        # 한국어 텍스트 정규화
        optimized_markdown = self._normalize_korean_text(result.markdown)
        
        # 한국어 제목 추출 개선
        if not result.title:
            result.title = self._extract_korean_title(optimized_markdown)
        
        return DocumentConverterResult(
            markdown=optimized_markdown,
            title=result.title,
            metadata=result.metadata
        )
    
    def _normalize_korean_text(self, text: str) -> str:
        """한국어 텍스트 정규화"""
        import re
        
        # 한글 공백 정규화
        text = re.sub(r'(\S)\s+(\S)', r'\1 \2', text)
        
        # 한글 문장 부호 정규화
        text = text.replace('․', '.')
        text = text.replace('，', ',')
        text = text.replace('：', ':')
        text = text.replace('；', ';')
        text = text.replace('？', '?')
        text = text.replace('！', '!')
        
        return text
    
    def _extract_korean_title(self, markdown: str) -> Optional[str]:
        """한국어 제목 추출"""
        import re
        
        # 첫 번째 헤딩 찾기
        match = re.search(r'^#\s+(.+)$', markdown, re.MULTILINE)
        if match:
            return match.group(1).strip()
        
        # 첫 번째 줄이 제목인지 확인
        lines = markdown.split('\n')
        if lines and len(lines[0]) < 100:  # 제목은 보통 100자 이하
            return lines[0].strip()
        
        return None
    
    def analyze_structure(self, source: Union[str, Path, BinaryIO]) -> Dict[str, Any]:
        """문서 구조 분석"""
        result = self.convert(source)
        
        return {
            'document_type': self._detect_document_type(result),
            'word_count': len(result.markdown.split()),
            'character_count': len(result.markdown),
            'headings': self._extract_headings(result.markdown),
            'images': self._extract_images(result.markdown),
            'tables': self._extract_tables(result.markdown),
            'links': self._extract_links(result.markdown),
            'language': self._detect_language(result.markdown),
            'metadata': result.metadata
        }
    
    def _detect_document_type(self, result: DocumentConverterResult) -> str:
        """문서 타입 감지"""
        markdown = result.markdown
        
        # 표가 많으면 스프레드시트
        if markdown.count('|') > 20:
            return 'spreadsheet'
        
        # 코드 블록이 많으면 기술 문서
        if markdown.count('```') > 5:
            return 'technical'
        
        # 이미지가 많으면 프레젠테이션
        if markdown.count('![') > 5:
            return 'presentation'
        
        # 링크가 많으면 웹 페이지
        if markdown.count('](') > 10:
            return 'webpage'
        
        return 'document'
    
    def _extract_headings(self, markdown: str) -> List[Dict[str, Any]]:
        """헤딩 추출"""
        import re
        
        headings = []
        for match in re.finditer(r'^(#{1,6})\s+(.+)$', markdown, re.MULTILINE):
            level = len(match.group(1))
            text = match.group(2).strip()
            headings.append({
                'level': level,
                'text': text,
                'line': markdown[:match.start()].count('\n') + 1
            })
        
        return headings
    
    def _extract_images(self, markdown: str) -> List[Dict[str, Any]]:
        """이미지 추출"""
        import re
        
        images = []
        for match in re.finditer(r'!\[([^\]]*)\]\(([^\)]+)\)', markdown):
            alt_text = match.group(1)
            url = match.group(2)
            images.append({
                'alt_text': alt_text,
                'url': url,
                'line': markdown[:match.start()].count('\n') + 1
            })
        
        return images
    
    def _extract_tables(self, markdown: str) -> List[Dict[str, Any]]:
        """테이블 추출"""
        import re
        
        tables = []
        table_pattern = r'(\|[^\n]+\|(?:\n\|[^\n]+\|)+)'
        
        for match in re.finditer(table_pattern, markdown, re.MULTILINE):
            table_text = match.group(1)
            lines = table_text.split('\n')
            
            # 헤더와 데이터 분리
            header_line = lines[0] if lines else ''
            data_lines = lines[2:] if len(lines) > 2 else []
            
            columns = len(header_line.split('|')) - 2  # 앞뒤 빈 부분 제외
            rows = len(data_lines)
            
            tables.append({
                'columns': columns,
                'rows': rows,
                'header': header_line.strip(),
                'line': markdown[:match.start()].count('\n') + 1
            })
        
        return tables
    
    def _extract_links(self, markdown: str) -> List[Dict[str, Any]]:
        """링크 추출"""
        import re
        
        links = []
        for match in re.finditer(r'\[([^\]]+)\]\(([^\)]+)\)', markdown):
            text = match.group(1)
            url = match.group(2)
            links.append({
                'text': text,
                'url': url,
                'line': markdown[:match.start()].count('\n') + 1
            })
        
        return links
    
    def _detect_language(self, text: str) -> str:
        """언어 감지"""
        import re
        
        # 한글 문자 비율 계산
        korean_chars = len(re.findall(r'[가-힣]', text))
        total_chars = len(re.findall(r'[a-zA-Z가-힣]', text))
        
        if total_chars > 0:
            korean_ratio = korean_chars / total_chars
            if korean_ratio > 0.3:
                return 'korean'
        
        # 영어 문자 비율 계산
        english_chars = len(re.findall(r'[a-zA-Z]', text))
        if total_chars > 0:
            english_ratio = english_chars / total_chars
            if english_ratio > 0.7:
                return 'english'
        
        return 'unknown'
    
    def get_supported_formats(self) -> Dict[str, List[Dict[str, Any]]]:
        """지원 형식 목록 반환"""
        formats = {
            'documents': [],
            'images': [],
            'audio': [],
            'web': [],
            'data': [],
            'archives': []
        }
        
        for converter_reg in self._converters:
            converter = converter_reg.converter
            format_info = converter.get_format_info()
            
            category = format_info.get('category', 'documents')
            if category in formats:
                formats[category].append(format_info)
        
        return formats

@dataclass
class ConverterRegistration:
    """변환기 등록 정보"""
    converter: DocumentConverter
    priority: float
```

## 2. 기본 변환기 클래스

### 2.1 DocumentConverter 기본 클래스
```python
# src/markitdown_mcp_enhanced/core/base_converter.py
from abc import ABC, abstractmethod
from typing import BinaryIO, Dict, Any, Optional, List
from dataclasses import dataclass

from .stream_info import StreamInfo

@dataclass
class DocumentConverterResult:
    """변환 결과 클래스"""
    markdown: str
    title: Optional[str] = None
    metadata: Optional[Dict[str, Any]] = None
    
    @property
    def text_content(self) -> str:
        """하위 호환성을 위한 속성"""
        return self.markdown

class DocumentConverter(ABC):
    """문서 변환기 기본 클래스"""
    
    def __init__(self, korean_support: bool = False):
        self.korean_support = korean_support
        self.priority = 0.0
    
    @abstractmethod
    def accepts(self, file_stream: BinaryIO, stream_info: StreamInfo, **kwargs) -> bool:
        """파일 처리 가능 여부 판단"""
        pass
    
    @abstractmethod
    def convert(self, file_stream: BinaryIO, stream_info: StreamInfo, **kwargs) -> DocumentConverterResult:
        """파일 변환 수행"""
        pass
    
    def get_format_info(self) -> Dict[str, Any]:
        """지원 형식 정보 반환"""
        return {
            'name': self.__class__.__name__.replace('Converter', ''),
            'description': self.__doc__ or 'No description',
            'extensions': getattr(self, 'supported_extensions', []),
            'mimetypes': getattr(self, 'supported_mimetypes', []),
            'category': getattr(self, 'category', 'documents')
        }
    
    def _normalize_korean_text(self, text: str) -> str:
        """한국어 텍스트 정규화"""
        if not self.korean_support:
            return text
        
        import re
        
        # 한글 공백 정규화
        text = re.sub(r'(\S)\s+(\S)', r'\1 \2', text)
        
        # 한글 문장 부호 정규화
        korean_punctuation = {
            '․': '.',
            '，': ',',
            '：': ':',
            '；': ';',
            '？': '?',
            '！': '!',
            '（': '(',
            '）': ')',
            '「': '"',
            '」': '"',
            '『': '"',
            '』': '"'
        }
        
        for korean, english in korean_punctuation.items():
            text = text.replace(korean, english)
        
        return text
    
    def _extract_metadata(self, stream: BinaryIO, stream_info: StreamInfo) -> Dict[str, Any]:
        """기본 메타데이터 추출"""
        metadata = {}
        
        if stream_info.filename:
            metadata['filename'] = stream_info.filename
        
        if stream_info.mimetype:
            metadata['mimetype'] = stream_info.mimetype
        
        if stream_info.url:
            metadata['source_url'] = stream_info.url
        
        if stream_info.local_path:
            from pathlib import Path
            path = Path(stream_info.local_path)
            metadata['file_size'] = path.stat().st_size
            metadata['modification_time'] = path.stat().st_mtime
        
        return metadata
    
    def _format_title(self, title: str) -> str:
        """제목 포맷팅"""
        if not title:
            return ""
        
        # 제목 정리
        title = title.strip()
        
        # 한국어 제목 정규화
        if self.korean_support:
            title = self._normalize_korean_text(title)
        
        # 너무 긴 제목 축약
        if len(title) > 100:
            title = title[:97] + "..."
        
        return title
    
    def _format_markdown_header(self, title: str, metadata: Optional[Dict[str, Any]] = None) -> str:
        """마크다운 헤더 생성"""
        header = f"# {self._format_title(title)}\n\n"
        
        if metadata:
            header += "---\n"
            for key, value in metadata.items():
                header += f"{key}: {value}\n"
            header += "---\n\n"
        
        return header
    
    def _clean_markdown(self, markdown: str) -> str:
        """마크다운 정리"""
        import re
        
        # 연속된 빈 줄 제거
        markdown = re.sub(r'\n\s*\n\s*\n', '\n\n', markdown)
        
        # 시작과 끝 공백 제거
        markdown = markdown.strip()
        
        # 한국어 최적화
        if self.korean_support:
            markdown = self._normalize_korean_text(markdown)
        
        return markdown
```

### 2.2 StreamInfo 클래스
```python
# src/markitdown_mcp_enhanced/core/stream_info.py
from dataclasses import dataclass
from typing import Optional
from pathlib import Path

@dataclass
class StreamInfo:
    """스트림 정보 클래스"""
    mimetype: Optional[str] = None
    extension: Optional[str] = None
    charset: Optional[str] = None
    filename: Optional[str] = None
    local_path: Optional[str] = None
    url: Optional[str] = None
    
    def __post_init__(self):
        """후처리"""
        # 확장자 정규화
        if self.extension and not self.extension.startswith('.'):
            self.extension = '.' + self.extension
        
        # 파일명에서 확장자 추출
        if self.filename and not self.extension:
            self.extension = Path(self.filename).suffix.lower()
    
    def __str__(self) -> str:
        parts = []
        if self.mimetype:
            parts.append(f"mimetype={self.mimetype}")
        if self.extension:
            parts.append(f"ext={self.extension}")
        if self.filename:
            parts.append(f"filename={self.filename}")
        return f"StreamInfo({', '.join(parts)})"
    
    def __eq__(self, other) -> bool:
        if not isinstance(other, StreamInfo):
            return False
        return (self.mimetype == other.mimetype and 
                self.extension == other.extension and
                self.filename == other.filename)
    
    def matches_extension(self, extensions: List[str]) -> bool:
        """확장자 매칭"""
        if not self.extension:
            return False
        return self.extension.lower() in [ext.lower() for ext in extensions]
    
    def matches_mimetype(self, mimetypes: List[str]) -> bool:
        """MIME 타입 매칭"""
        if not self.mimetype:
            return False
        return any(self.mimetype.startswith(mt) for mt in mimetypes)
```

### 2.3 예외 클래스
```python
# src/markitdown_mcp_enhanced/core/exceptions.py
class MarkItDownException(Exception):
    """기본 MarkItDown 예외"""
    pass

class UnsupportedFormatException(MarkItDownException):
    """지원하지 않는 형식 예외"""
    pass

class FileConversionException(MarkItDownException):
    """파일 변환 실패 예외"""
    pass

class MissingDependencyException(MarkItDownException):
    """의존성 누락 예외"""
    pass

class NetworkException(MarkItDownException):
    """네트워크 관련 예외"""
    pass

class AuthenticationException(MarkItDownException):
    """인증 관련 예외"""
    pass

class ConfigurationException(MarkItDownException):
    """설정 관련 예외"""
    pass
```

이 아키텍처를 바탕으로 각 파일 형식별 변환기를 구현하고, 플러그인 시스템을 통해 확장할 수 있습니다.