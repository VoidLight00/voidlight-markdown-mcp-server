# 스트림 처리 및 추가 변환기 구현

## 1. 이미지 변환기 구현

### 1.1 이미지 변환기
```python
# src/markitdown_mcp_enhanced/converters/image_converter.py
import io
import base64
from typing import BinaryIO, Dict, Any, Optional
import logging

from ..core.base_converter import DocumentConverter, DocumentConverterResult
from ..core.stream_info import StreamInfo
from ..core.exceptions import MissingDependencyException, FileConversionException
from ..utils.format_utils import format_file_size

logger = logging.getLogger(__name__)

class ImageConverter(DocumentConverter):
    """이미지 파일 변환기"""
    
    supported_extensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.webp']
    supported_mimetypes = ['image/jpeg', 'image/png', 'image/gif', 'image/bmp', 'image/tiff', 'image/webp']
    category = 'images'
    
    def __init__(self, llm_client=None, llm_model: str = "gpt-4o", 
                 exiftool_path: Optional[str] = None, korean_support: bool = True):
        super().__init__(korean_support=korean_support)
        self.llm_client = llm_client
        self.llm_model = llm_model
        self.exiftool_path = exiftool_path
        self.priority = 1.0
        
        # 의존성 확인
        self._check_dependencies()
    
    def _check_dependencies(self):
        """의존성 확인"""
        try:
            from PIL import Image
            self.pil_available = True
        except ImportError:
            self.pil_available = False
        
        try:
            import exifread
            self.exifread_available = True
        except ImportError:
            self.exifread_available = False
        
        # ExifTool 확인
        import shutil
        self.exiftool_available = bool(shutil.which(self.exiftool_path or 'exiftool'))
    
    def accepts(self, file_stream: BinaryIO, stream_info: StreamInfo, **kwargs) -> bool:
        """이미지 파일 처리 가능 여부"""
        return (stream_info.matches_mimetype([mime for mime in self.supported_mimetypes]) or
                stream_info.matches_extension(self.supported_extensions))
    
    def convert(self, file_stream: BinaryIO, stream_info: StreamInfo, **kwargs) -> DocumentConverterResult:
        """이미지 변환 수행"""
        logger.info(f"Converting image: {stream_info.filename}")
        
        try:
            # 이미지 기본 정보 추출
            image_info = self._extract_image_info(file_stream, stream_info)
            
            # EXIF 데이터 추출
            exif_data = self._extract_exif_data(file_stream, stream_info)
            
            # LLM을 사용한 이미지 설명 생성
            description = None
            if self.llm_client and kwargs.get('extract_images', False):
                description = self._generate_image_description(file_stream, stream_info)
            
            # 마크다운 생성
            markdown = self._create_image_markdown(image_info, exif_data, description, stream_info)
            
            # 메타데이터 생성
            metadata = self._create_image_metadata(image_info, exif_data, stream_info)
            
            # 제목 생성
            title = self._generate_image_title(image_info, description, stream_info)
            
            return DocumentConverterResult(
                markdown=self._clean_markdown(markdown),
                title=title,
                metadata=metadata
            )
            
        except Exception as e:
            raise FileConversionException(f"Image conversion failed: {e}")
    
    def _extract_image_info(self, file_stream: BinaryIO, stream_info: StreamInfo) -> Dict[str, Any]:
        """이미지 기본 정보 추출"""
        info = {}
        
        if not self.pil_available:
            return info
        
        try:
            from PIL import Image
            
            file_stream.seek(0)
            with Image.open(file_stream) as img:
                info['width'] = img.width
                info['height'] = img.height
                info['format'] = img.format
                info['mode'] = img.mode
                info['size'] = f"{img.width}x{img.height}"
                
                # 색상 정보
                if hasattr(img, 'getcolors'):
                    try:
                        colors = img.getcolors(maxcolors=256)
                        if colors:
                            info['dominant_colors'] = len(colors)
                    except:
                        pass
                
                # 투명도 정보
                info['has_transparency'] = img.mode in ('RGBA', 'LA') or 'transparency' in img.info
                
        except Exception as e:
            logger.debug(f"Image info extraction failed: {e}")
        
        return info
    
    def _extract_exif_data(self, file_stream: BinaryIO, stream_info: StreamInfo) -> Dict[str, Any]:
        """EXIF 데이터 추출"""
        exif_data = {}
        
        # ExifTool 사용 (가장 포괄적)
        if self.exiftool_available:
            try:
                exif_data.update(self._extract_exif_with_exiftool(file_stream))
            except Exception as e:
                logger.debug(f"ExifTool extraction failed: {e}")
        
        # exifread 사용 (백업)
        if self.exifread_available and not exif_data:
            try:
                exif_data.update(self._extract_exif_with_exifread(file_stream))
            except Exception as e:
                logger.debug(f"exifread extraction failed: {e}")
        
        # PIL 사용 (최소한의 정보)
        if self.pil_available and not exif_data:
            try:
                exif_data.update(self._extract_exif_with_pil(file_stream))
            except Exception as e:
                logger.debug(f"PIL EXIF extraction failed: {e}")
        
        return exif_data
    
    def _extract_exif_with_exiftool(self, file_stream: BinaryIO) -> Dict[str, Any]:
        """ExifTool로 EXIF 데이터 추출"""
        import subprocess
        import json
        import tempfile
        
        # 임시 파일 생성
        with tempfile.NamedTemporaryFile(delete=False) as temp_file:
            file_stream.seek(0)
            temp_file.write(file_stream.read())
            temp_file_path = temp_file.name
        
        try:
            # ExifTool 실행
            cmd = [self.exiftool_path or 'exiftool', '-j', temp_file_path]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            
            if result.returncode == 0:
                data = json.loads(result.stdout)
                if data and len(data) > 0:
                    return self._normalize_exif_data(data[0])
            
        except Exception as e:
            logger.debug(f"ExifTool failed: {e}")
        finally:
            # 임시 파일 삭제
            import os
            try:
                os.unlink(temp_file_path)
            except:
                pass
        
        return {}
    
    def _extract_exif_with_exifread(self, file_stream: BinaryIO) -> Dict[str, Any]:
        """exifread로 EXIF 데이터 추출"""
        import exifread
        
        file_stream.seek(0)
        tags = exifread.process_file(file_stream, details=False)
        
        exif_data = {}
        for tag, value in tags.items():
            if tag.startswith('JPEGThumbnail'):
                continue
            exif_data[tag] = str(value)
        
        return self._normalize_exif_data(exif_data)
    
    def _extract_exif_with_pil(self, file_stream: BinaryIO) -> Dict[str, Any]:
        """PIL로 EXIF 데이터 추출"""
        from PIL import Image
        from PIL.ExifTags import TAGS
        
        file_stream.seek(0)
        with Image.open(file_stream) as img:
            exif_dict = {}
            if hasattr(img, '_getexif'):
                exif = img._getexif()
                if exif:
                    for tag_id, value in exif.items():
                        tag = TAGS.get(tag_id, tag_id)
                        exif_dict[tag] = str(value)
            
            return self._normalize_exif_data(exif_dict)
    
    def _normalize_exif_data(self, raw_data: Dict[str, Any]) -> Dict[str, Any]:
        """EXIF 데이터 정규화"""
        normalized = {}
        
        # 주요 필드 매핑
        field_mapping = {
            'DateTime': 'date_taken',
            'DateTimeOriginal': 'date_taken',
            'CreateDate': 'date_taken',
            'Make': 'camera_make',
            'Model': 'camera_model',
            'LensModel': 'lens_model',
            'ExposureTime': 'shutter_speed',
            'FNumber': 'aperture',
            'ISO': 'iso',
            'ISOSpeedRatings': 'iso',
            'FocalLength': 'focal_length',
            'GPS GPSLatitude': 'gps_latitude',
            'GPS GPSLongitude': 'gps_longitude',
            'GPS GPSAltitude': 'gps_altitude',
            'ImageWidth': 'width',
            'ImageHeight': 'height',
            'ImageDescription': 'description',
            'Artist': 'artist',
            'Copyright': 'copyright',
            'Software': 'software'
        }
        
        for key, value in raw_data.items():
            # 정규화된 키 찾기
            normalized_key = None
            for orig_key, norm_key in field_mapping.items():
                if orig_key in key:
                    normalized_key = norm_key
                    break
            
            if normalized_key:
                normalized[normalized_key] = value
            else:
                # 원본 키 사용 (소문자 변환)
                normalized[key.lower().replace(' ', '_')] = value
        
        return normalized
    
    def _generate_image_description(self, file_stream: BinaryIO, stream_info: StreamInfo) -> Optional[str]:
        """LLM을 사용한 이미지 설명 생성"""
        if not self.llm_client:
            return None
        
        try:
            # 이미지를 base64로 인코딩
            file_stream.seek(0)
            image_data = file_stream.read()
            base64_image = base64.b64encode(image_data).decode('utf-8')
            
            # OpenAI API 호출
            response = self.llm_client.chat.completions.create(
                model=self.llm_model,
                messages=[
                    {
                        "role": "user",
                        "content": [
                            {
                                "type": "text",
                                "text": "이 이미지를 자세히 설명해주세요. 주요 객체, 색상, 구성, 분위기 등을 포함해서 설명해주세요." if self.korean_support else "Describe this image in detail. Include main objects, colors, composition, and atmosphere."
                            },
                            {
                                "type": "image_url",
                                "image_url": {
                                    "url": f"data:image/jpeg;base64,{base64_image}"
                                }
                            }
                        ]
                    }
                ],
                max_tokens=500,
                temperature=0.3
            )
            
            if response.choices:
                return response.choices[0].message.content
            
        except Exception as e:
            logger.warning(f"Image description generation failed: {e}")
        
        return None
    
    def _create_image_markdown(self, image_info: Dict[str, Any], 
                             exif_data: Dict[str, Any], 
                             description: Optional[str],
                             stream_info: StreamInfo) -> str:
        """이미지 마크다운 생성"""
        markdown = ""
        
        # 이미지 표시
        if stream_info.filename:
            alt_text = description[:100] + "..." if description and len(description) > 100 else (description or "이미지")
            markdown += f"![{alt_text}]({stream_info.filename})\n\n"
        
        # 이미지 설명
        if description:
            markdown += f"## 이미지 설명\n\n{description}\n\n"
        
        # 기본 정보
        if image_info:
            markdown += "## 이미지 정보\n\n"
            
            if 'size' in image_info:
                markdown += f"**크기**: {image_info['size']}\n"
            if 'format' in image_info:
                markdown += f"**형식**: {image_info['format']}\n"
            if 'mode' in image_info:
                markdown += f"**색상 모드**: {image_info['mode']}\n"
            if 'has_transparency' in image_info:
                markdown += f"**투명도**: {'있음' if image_info['has_transparency'] else '없음'}\n"
            
            markdown += "\n"
        
        # EXIF 데이터
        if exif_data:
            markdown += "## EXIF 데이터\n\n"
            
            # 촬영 정보
            camera_info = []
            if 'camera_make' in exif_data:
                camera_info.append(f"**제조사**: {exif_data['camera_make']}")
            if 'camera_model' in exif_data:
                camera_info.append(f"**모델**: {exif_data['camera_model']}")
            if 'lens_model' in exif_data:
                camera_info.append(f"**렌즈**: {exif_data['lens_model']}")
            
            if camera_info:
                markdown += "\n".join(camera_info) + "\n\n"
            
            # 촬영 설정
            settings_info = []
            if 'shutter_speed' in exif_data:
                settings_info.append(f"**셔터 속도**: {exif_data['shutter_speed']}")
            if 'aperture' in exif_data:
                settings_info.append(f"**조리개**: f/{exif_data['aperture']}")
            if 'iso' in exif_data:
                settings_info.append(f"**ISO**: {exif_data['iso']}")
            if 'focal_length' in exif_data:
                settings_info.append(f"**초점 거리**: {exif_data['focal_length']}")
            
            if settings_info:
                markdown += "\n".join(settings_info) + "\n\n"
            
            # 날짜 정보
            if 'date_taken' in exif_data:
                markdown += f"**촬영 일시**: {exif_data['date_taken']}\n\n"
            
            # 위치 정보
            if any(key in exif_data for key in ['gps_latitude', 'gps_longitude']):
                markdown += "### 위치 정보\n\n"
                if 'gps_latitude' in exif_data:
                    markdown += f"**위도**: {exif_data['gps_latitude']}\n"
                if 'gps_longitude' in exif_data:
                    markdown += f"**경도**: {exif_data['gps_longitude']}\n"
                if 'gps_altitude' in exif_data:
                    markdown += f"**고도**: {exif_data['gps_altitude']}\n"
                markdown += "\n"
        
        return markdown
    
    def _create_image_metadata(self, image_info: Dict[str, Any], 
                             exif_data: Dict[str, Any], 
                             stream_info: StreamInfo) -> Dict[str, Any]:
        """이미지 메타데이터 생성"""
        metadata = self._extract_metadata(None, stream_info)
        
        # 이미지 정보 추가
        metadata.update(image_info)
        
        # EXIF 데이터 추가
        for key, value in exif_data.items():
            metadata[f'exif_{key}'] = value
        
        return metadata
    
    def _generate_image_title(self, image_info: Dict[str, Any], 
                            description: Optional[str],
                            stream_info: StreamInfo) -> Optional[str]:
        """이미지 제목 생성"""
        # 파일명 기반 제목
        if stream_info.filename:
            title = stream_info.filename
            if '.' in title:
                title = title.rsplit('.', 1)[0]
            return self._format_title(title)
        
        # 설명 기반 제목
        if description:
            words = description.split()
            if len(words) > 0:
                title = ' '.join(words[:8])  # 첫 8단어
                if len(words) > 8:
                    title += "..."
                return self._format_title(title)
        
        # 기본 제목
        return "이미지"
```

### 1.2 오디오 변환기
```python
# src/markitdown_mcp_enhanced/converters/audio_converter.py
import tempfile
import os
from typing import BinaryIO, Dict, Any, Optional
import logging

from ..core.base_converter import DocumentConverter, DocumentConverterResult
from ..core.stream_info import StreamInfo
from ..core.exceptions import MissingDependencyException, FileConversionException
from ..utils.format_utils import format_file_size, format_timestamp

logger = logging.getLogger(__name__)

class AudioConverter(DocumentConverter):
    """오디오 파일 변환기"""
    
    supported_extensions = ['.mp3', '.wav', '.m4a', '.flac', '.ogg', '.aac']
    supported_mimetypes = ['audio/mpeg', 'audio/wav', 'audio/mp4', 'audio/flac', 'audio/ogg', 'audio/aac']
    category = 'audio'
    
    def __init__(self, korean_support: bool = True):
        super().__init__(korean_support=korean_support)
        self.priority = 1.1
        
        # 의존성 확인
        self._check_dependencies()
    
    def _check_dependencies(self):
        """의존성 확인"""
        try:
            import mutagen
            self.mutagen_available = True
        except ImportError:
            self.mutagen_available = False
        
        try:
            import speech_recognition as sr
            self.sr_available = True
        except ImportError:
            self.sr_available = False
        
        try:
            from pydub import AudioSegment
            self.pydub_available = True
        except ImportError:
            self.pydub_available = False
    
    def accepts(self, file_stream: BinaryIO, stream_info: StreamInfo, **kwargs) -> bool:
        """오디오 파일 처리 가능 여부"""
        return (stream_info.matches_mimetype([mime for mime in self.supported_mimetypes]) or
                stream_info.matches_extension(self.supported_extensions))
    
    def convert(self, file_stream: BinaryIO, stream_info: StreamInfo, **kwargs) -> DocumentConverterResult:
        """오디오 변환 수행"""
        logger.info(f"Converting audio: {stream_info.filename}")
        
        try:
            # 오디오 메타데이터 추출
            metadata = self._extract_audio_metadata(file_stream, stream_info)
            
            # 음성 전사
            transcription = None
            if self.sr_available and self.pydub_available:
                try:
                    transcription = self._transcribe_audio(file_stream, stream_info)
                except Exception as e:
                    logger.warning(f"Audio transcription failed: {e}")
            
            # 마크다운 생성
            markdown = self._create_audio_markdown(metadata, transcription, stream_info)
            
            # 제목 생성
            title = self._generate_audio_title(metadata, transcription, stream_info)
            
            return DocumentConverterResult(
                markdown=self._clean_markdown(markdown),
                title=title,
                metadata=metadata
            )
            
        except Exception as e:
            raise FileConversionException(f"Audio conversion failed: {e}")
    
    def _extract_audio_metadata(self, file_stream: BinaryIO, stream_info: StreamInfo) -> Dict[str, Any]:
        """오디오 메타데이터 추출"""
        metadata = self._extract_metadata(file_stream, stream_info)
        
        if not self.mutagen_available:
            return metadata
        
        try:
            import mutagen
            
            # 임시 파일 생성
            with tempfile.NamedTemporaryFile(delete=False, suffix=stream_info.extension or '.mp3') as temp_file:
                file_stream.seek(0)
                temp_file.write(file_stream.read())
                temp_file_path = temp_file.name
            
            try:
                # mutagen으로 메타데이터 읽기
                audio_file = mutagen.File(temp_file_path)
                
                if audio_file:
                    # 기본 정보
                    if hasattr(audio_file, 'info'):
                        info = audio_file.info
                        if hasattr(info, 'length'):
                            metadata['duration'] = info.length
                        if hasattr(info, 'bitrate'):
                            metadata['bitrate'] = info.bitrate
                        if hasattr(info, 'channels'):
                            metadata['channels'] = info.channels
                        if hasattr(info, 'sample_rate'):
                            metadata['sample_rate'] = info.sample_rate
                    
                    # 태그 정보
                    if hasattr(audio_file, 'tags') and audio_file.tags:
                        tags = audio_file.tags
                        
                        # 공통 태그 매핑
                        tag_mapping = {
                            'TIT2': 'title',  # ID3v2
                            'TPE1': 'artist',  # ID3v2
                            'TALB': 'album',  # ID3v2
                            'TDRC': 'date',  # ID3v2
                            'TCON': 'genre',  # ID3v2
                            'TRCK': 'track',  # ID3v2
                            'TPE2': 'album_artist',  # ID3v2
                            'TITLE': 'title',  # Vorbis
                            'ARTIST': 'artist',  # Vorbis
                            'ALBUM': 'album',  # Vorbis
                            'DATE': 'date',  # Vorbis
                            'GENRE': 'genre',  # Vorbis
                            'TRACKNUMBER': 'track',  # Vorbis
                            'ALBUMARTIST': 'album_artist',  # Vorbis
                            '©nam': 'title',  # MP4
                            '©ART': 'artist',  # MP4
                            '©alb': 'album',  # MP4
                            '©day': 'date',  # MP4
                            '©gen': 'genre',  # MP4
                            'trkn': 'track',  # MP4
                            'aART': 'album_artist',  # MP4
                        }
                        
                        for tag_key, meta_key in tag_mapping.items():
                            if tag_key in tags:
                                value = tags[tag_key]
                                if isinstance(value, list) and value:
                                    value = value[0]
                                metadata[meta_key] = str(value)
                
            finally:
                # 임시 파일 삭제
                try:
                    os.unlink(temp_file_path)
                except:
                    pass
            
        except Exception as e:
            logger.debug(f"Audio metadata extraction failed: {e}")
        
        return metadata
    
    def _transcribe_audio(self, file_stream: BinaryIO, stream_info: StreamInfo) -> Optional[str]:
        """오디오 전사"""
        if not (self.sr_available and self.pydub_available):
            return None
        
        try:
            import speech_recognition as sr
            from pydub import AudioSegment
            
            # 임시 파일 생성
            with tempfile.NamedTemporaryFile(delete=False, suffix=stream_info.extension or '.mp3') as temp_file:
                file_stream.seek(0)
                temp_file.write(file_stream.read())
                temp_file_path = temp_file.name
            
            try:
                # 오디오 로드 및 WAV 변환
                audio = AudioSegment.from_file(temp_file_path)
                
                # 너무 긴 오디오는 처음 5분만 처리
                if len(audio) > 5 * 60 * 1000:  # 5분 = 300초 = 300,000ms
                    audio = audio[:5 * 60 * 1000]
                    logger.info("Audio truncated to 5 minutes for transcription")
                
                # WAV 파일로 저장
                wav_path = temp_file_path + '.wav'
                audio.export(wav_path, format='wav')
                
                # 음성 인식
                recognizer = sr.Recognizer()
                with sr.AudioFile(wav_path) as source:
                    audio_data = recognizer.record(source)
                
                # 한국어 우선 시도
                if self.korean_support:
                    try:
                        text = recognizer.recognize_google(audio_data, language='ko-KR')
                        return text
                    except sr.UnknownValueError:
                        logger.debug("Korean speech recognition failed, trying English")
                    except sr.RequestError as e:
                        logger.warning(f"Korean speech recognition service error: {e}")
                
                # 영어 시도
                try:
                    text = recognizer.recognize_google(audio_data, language='en-US')
                    return text
                except sr.UnknownValueError:
                    logger.debug("English speech recognition failed")
                except sr.RequestError as e:
                    logger.warning(f"English speech recognition service error: {e}")
                
                # 기타 언어 시도
                for lang in ['ja-JP', 'zh-CN', 'es-ES', 'fr-FR', 'de-DE']:
                    try:
                        text = recognizer.recognize_google(audio_data, language=lang)
                        return text
                    except (sr.UnknownValueError, sr.RequestError):
                        continue
                
            finally:
                # 임시 파일들 삭제
                try:
                    os.unlink(temp_file_path)
                    if os.path.exists(wav_path):
                        os.unlink(wav_path)
                except:
                    pass
            
        except Exception as e:
            logger.debug(f"Audio transcription failed: {e}")
        
        return None
    
    def _create_audio_markdown(self, metadata: Dict[str, Any], 
                             transcription: Optional[str],
                             stream_info: StreamInfo) -> str:
        """오디오 마크다운 생성"""
        markdown = ""
        
        # 오디오 파일 정보
        if stream_info.filename:
            markdown += f"# 오디오 파일: {stream_info.filename}\n\n"
        
        # 기본 정보
        markdown += "## 오디오 정보\n\n"
        
        if 'duration' in metadata:
            duration = metadata['duration']
            hours = int(duration // 3600)
            minutes = int((duration % 3600) // 60)
            seconds = int(duration % 60)
            
            if hours > 0:
                duration_str = f"{hours}:{minutes:02d}:{seconds:02d}"
            else:
                duration_str = f"{minutes}:{seconds:02d}"
            
            markdown += f"**재생 시간**: {duration_str}\n"
        
        if 'bitrate' in metadata:
            markdown += f"**비트레이트**: {metadata['bitrate']} kbps\n"
        
        if 'sample_rate' in metadata:
            markdown += f"**샘플레이트**: {metadata['sample_rate']} Hz\n"
        
        if 'channels' in metadata:
            channels = metadata['channels']
            channel_str = "모노" if channels == 1 else ("스테레오" if channels == 2 else f"{channels}채널")
            markdown += f"**채널**: {channel_str}\n"
        
        markdown += "\n"
        
        # 메타데이터 (태그 정보)
        tag_info = []
        for key in ['title', 'artist', 'album', 'date', 'genre', 'track', 'album_artist']:
            if key in metadata:
                tag_info.append((key, metadata[key]))
        
        if tag_info:
            markdown += "## 메타데이터\n\n"
            
            tag_labels = {
                'title': '제목',
                'artist': '아티스트',
                'album': '앨범',
                'date': '발매일',
                'genre': '장르',
                'track': '트랙',
                'album_artist': '앨범 아티스트'
            }
            
            for key, value in tag_info:
                label = tag_labels.get(key, key)
                markdown += f"**{label}**: {value}\n"
            
            markdown += "\n"
        
        # 전사 결과
        if transcription:
            markdown += "## 음성 전사\n\n"
            markdown += f"{transcription}\n\n"
        else:
            markdown += "## 음성 전사\n\n"
            markdown += "*음성 전사를 사용할 수 없습니다.*\n\n"
        
        return markdown
    
    def _generate_audio_title(self, metadata: Dict[str, Any], 
                            transcription: Optional[str],
                            stream_info: StreamInfo) -> Optional[str]:
        """오디오 제목 생성"""
        # 메타데이터에서 제목 추출
        if 'title' in metadata:
            title = metadata['title']
            if 'artist' in metadata:
                title += f" - {metadata['artist']}"
            return self._format_title(title)
        
        # 파일명 기반 제목
        if stream_info.filename:
            title = stream_info.filename
            if '.' in title:
                title = title.rsplit('.', 1)[0]
            return self._format_title(title)
        
        # 전사 내용 기반 제목
        if transcription:
            words = transcription.split()
            if len(words) > 0:
                title = ' '.join(words[:6])  # 첫 6단어
                if len(words) > 6:
                    title += "..."
                return self._format_title(title)
        
        # 기본 제목
        return "오디오 파일"
```

### 1.3 HTML 변환기
```python
# src/markitdown_mcp_enhanced/converters/html_converter.py
import re
from typing import BinaryIO, Dict, Any, Optional
import logging

from ..core.base_converter import DocumentConverter, DocumentConverterResult
from ..core.stream_info import StreamInfo
from ..core.exceptions import MissingDependencyException, FileConversionException
from ..utils.format_utils import clean_html, normalize_whitespace
from ..utils.stream_utils import read_stream_with_encoding

logger = logging.getLogger(__name__)

class HtmlConverter(DocumentConverter):
    """HTML 파일 변환기"""
    
    supported_extensions = ['.html', '.htm']
    supported_mimetypes = ['text/html', 'application/xhtml+xml']
    category = 'web'
    
    def __init__(self, korean_support: bool = True):
        super().__init__(korean_support=korean_support)
        self.priority = 2.0
        
        # 의존성 확인
        self._check_dependencies()
    
    def _check_dependencies(self):
        """의존성 확인"""
        try:
            from bs4 import BeautifulSoup
            self.bs4_available = True
        except ImportError:
            self.bs4_available = False
        
        try:
            import markdownify
            self.markdownify_available = True
        except ImportError:
            self.markdownify_available = False
    
    def accepts(self, file_stream: BinaryIO, stream_info: StreamInfo, **kwargs) -> bool:
        """HTML 파일 처리 가능 여부"""
        return (stream_info.matches_mimetype(['text/html', 'application/xhtml+xml']) or
                stream_info.matches_extension(['.html', '.htm']))
    
    def convert(self, file_stream: BinaryIO, stream_info: StreamInfo, **kwargs) -> DocumentConverterResult:
        """HTML 변환 수행"""
        logger.info(f"Converting HTML: {stream_info.filename}")
        
        if not self.bs4_available:
            raise MissingDependencyException("BeautifulSoup4 is required for HTML conversion")
        
        try:
            # HTML 내용 읽기
            html_content = read_stream_with_encoding(file_stream, stream_info.charset)
            
            # BeautifulSoup로 파싱
            from bs4 import BeautifulSoup
            soup = BeautifulSoup(html_content, 'html.parser')
            
            # 메타데이터 추출
            metadata = self._extract_html_metadata(soup, stream_info)
            
            # 제목 추출
            title = self._extract_html_title(soup)
            
            # 마크다운 변환
            if self.markdownify_available:
                markdown = self._convert_with_markdownify(soup)
            else:
                markdown = self._convert_with_beautifulsoup(soup)
            
            return DocumentConverterResult(
                markdown=self._clean_markdown(markdown),
                title=title,
                metadata=metadata
            )
            
        except Exception as e:
            raise FileConversionException(f"HTML conversion failed: {e}")
    
    def _extract_html_metadata(self, soup, stream_info: StreamInfo) -> Dict[str, Any]:
        """HTML 메타데이터 추출"""
        metadata = self._extract_metadata(None, stream_info)
        
        # 메타 태그에서 정보 추출
        for meta in soup.find_all('meta'):
            name = meta.get('name') or meta.get('property')
            content = meta.get('content')
            
            if name and content:
                # 일반적인 메타 태그
                if name in ['description', 'keywords', 'author', 'generator']:
                    metadata[name] = content
                
                # Open Graph 태그
                elif name.startswith('og:'):
                    metadata[name] = content
                
                # Twitter 카드 태그
                elif name.startswith('twitter:'):
                    metadata[name] = content
        
        # 제목 추출
        title_tag = soup.find('title')
        if title_tag:
            metadata['html_title'] = title_tag.get_text().strip()
        
        # 언어 정보
        html_tag = soup.find('html')
        if html_tag and html_tag.get('lang'):
            metadata['language'] = html_tag['lang']
        
        # 인코딩 정보
        for meta in soup.find_all('meta'):
            if meta.get('charset'):
                metadata['charset'] = meta['charset']
            elif meta.get('http-equiv') == 'Content-Type':
                content = meta.get('content', '')
                if 'charset=' in content:
                    charset = content.split('charset=')[1].split(';')[0]
                    metadata['charset'] = charset
        
        return metadata
    
    def _extract_html_title(self, soup) -> Optional[str]:
        """HTML 제목 추출"""
        # title 태그에서 추출
        title_tag = soup.find('title')
        if title_tag:
            title = title_tag.get_text().strip()
            if title:
                return self._format_title(title)
        
        # h1 태그에서 추출
        h1_tag = soup.find('h1')
        if h1_tag:
            title = h1_tag.get_text().strip()
            if title:
                return self._format_title(title)
        
        # Open Graph 제목
        og_title = soup.find('meta', {'property': 'og:title'})
        if og_title:
            title = og_title.get('content', '').strip()
            if title:
                return self._format_title(title)
        
        return None
    
    def _convert_with_markdownify(self, soup) -> str:
        """markdownify로 변환"""
        import markdownify
        
        # 불필요한 태그 제거
        for tag in soup(['script', 'style', 'meta', 'link', 'noscript']):
            tag.decompose()
        
        # 마크다운 변환
        markdown = markdownify.markdownify(
            str(soup),
            heading_style="ATX",
            bullets="-",
            strip=['script', 'style', 'meta', 'link', 'noscript'],
            convert=[
                'a', 'b', 'blockquote', 'br', 'code', 'div', 'em', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
                'hr', 'i', 'img', 'li', 'ol', 'p', 'pre', 'span', 'strong', 'table', 'tbody', 'td',
                'th', 'thead', 'tr', 'ul'
            ]
        )
        
        return markdown
    
    def _convert_with_beautifulsoup(self, soup) -> str:
        """BeautifulSoup으로 기본 변환"""
        markdown = ""
        
        # body 태그 찾기
        body = soup.find('body')
        if not body:
            body = soup
        
        # 주요 태그들 처리
        for element in body.find_all(['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'div', 'article', 'section']):
            text = element.get_text().strip()
            if not text:
                continue
            
            # 헤딩 처리
            if element.name in ['h1', 'h2', 'h3', 'h4', 'h5', 'h6']:
                level = int(element.name[1])
                markdown += f"{'#' * level} {text}\n\n"
            else:
                # 단락 처리
                markdown += f"{text}\n\n"
        
        # 리스트 처리
        for ul in body.find_all('ul'):
            for li in ul.find_all('li'):
                text = li.get_text().strip()
                if text:
                    markdown += f"- {text}\n"
            markdown += "\n"
        
        for ol in body.find_all('ol'):
            for i, li in enumerate(ol.find_all('li'), 1):
                text = li.get_text().strip()
                if text:
                    markdown += f"{i}. {text}\n"
            markdown += "\n"
        
        # 테이블 처리
        for table in body.find_all('table'):
            markdown += self._table_to_markdown(table)
            markdown += "\n"
        
        # 링크 처리
        for a in body.find_all('a'):
            href = a.get('href')
            text = a.get_text().strip()
            if href and text:
                markdown += f"[{text}]({href})\n"
        
        # 이미지 처리
        for img in body.find_all('img'):
            src = img.get('src')
            alt = img.get('alt', '')
            if src:
                markdown += f"![{alt}]({src})\n"
        
        return markdown
    
    def _table_to_markdown(self, table) -> str:
        """HTML 테이블을 마크다운으로 변환"""
        rows = []
        
        # 모든 행 수집
        for tr in table.find_all('tr'):
            cells = []
            for cell in tr.find_all(['td', 'th']):
                text = cell.get_text().strip()
                # 마크다운 테이블에서 파이프 문자 이스케이프
                text = text.replace('|', '\\|')
                cells.append(text)
            if cells:
                rows.append(cells)
        
        if not rows:
            return ""
        
        # 첫 번째 행을 헤더로 처리
        markdown = "| " + " | ".join(rows[0]) + " |\n"
        markdown += "| " + " | ".join(["---"] * len(rows[0])) + " |\n"
        
        # 나머지 행들
        for row in rows[1:]:
            # 헤더 열 수에 맞게 조정
            row = row[:len(rows[0])]
            row.extend([""] * (len(rows[0]) - len(row)))
            markdown += "| " + " | ".join(row) + " |\n"
        
        return markdown
```

이제 플러그인 시스템을 구현하겠습니다.

<function_calls>
<invoke name="TodoWrite">
<parameter name="todos">[{"content": "MCP \uc11c\ubc84 \uad6c\ucd95 \ud3f4\ub354 \ubc0f \ud558\uc704\uad6c\uc870 \uc0dd\uc131", "status": "completed", "priority": "high", "id": "30"}, {"content": "markitdown GitHub \ub9ac\ud3ec\uc9c0\ud1a0\ub9ac \ubd84\uc11d", "status": "completed", "priority": "high", "id": "31"}, {"content": "markitdown MCP \uc11c\ubc84 \uae30\ub2a5 \ubca4\uce58\ub9c8\ud0b9", "status": "completed", "priority": "high", "id": "32"}, {"content": "\ub3d9\uc77c \uae30\ub2a5 MCP \uc11c\ubc84 \uad6c\ud604", "status": "completed", "priority": "high", "id": "33"}, {"content": "\uc5c5\uadf8\ub808\uc774\ub4dc \ubc84\uc804 \uae30\ub2a5 \uc124\uacc4", "status": "pending", "priority": "medium", "id": "34"}, {"content": "\ud578\uc2ec \ubcc0\ud658 \uc5d4\uc9c4 \uad6c\ud604", "status": "completed", "priority": "high", "id": "35"}, {"content": "\uae30\ubcf8 \ubcc0\ud658\uae30 \uc2dc\uc2a4\ud15c \uad6c\ud604", "status": "completed", "priority": "high", "id": "36"}, {"content": "\ud50c\ub7ec\uadf8\uc778 \uc2dc\uc2a4\ud15c \uad6c\ud604", "status": "in_progress", "priority": "medium", "id": "37"}, {"content": "PDF \ubcc0\ud658\uae30 \uad6c\ud604", "status": "completed", "priority": "high", "id": "38"}, {"content": "DOCX \ubcc0\ud658\uae30 \uad6c\ud604", "status": "completed", "priority": "high", "id": "39"}, {"content": "\uc774\ubbf8\uc9c0 \ubcc0\ud658\uae30 \uad6c\ud604", "status": "completed", "priority": "high", "id": "40"}, {"content": "\uc624\ub514\uc624 \ubcc0\ud658\uae30 \uad6c\ud604", "status": "completed", "priority": "high", "id": "41"}, {"content": "HTML \ubcc0\ud658\uae30 \uad6c\ud604", "status": "completed", "priority": "medium", "id": "42"}, {"content": "\uc720\ud2f8\ub9ac\ud2f0 \ubaa8\ub4c8 \uad6c\ud604", "status": "completed", "priority": "medium", "id": "43"}]